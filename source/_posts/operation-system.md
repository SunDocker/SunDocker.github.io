---
title: 操作系统
abbrlink: cf3a69eb
date: 2022-09-23 10:31:06
tags:
  - 操作系统
  - 计算机
category: 学习资源
---

## 1 操作系统概述

### 1.1 基本概念

- 操作系统（Operating System，OS）是指
  - 控制和管理整个计算机系统的**硬件和软件资源**，并合理地**组织调度计算机的工作**和资源的分配，
  - 以提供给用户和其他软件方便的**接口调用和环境**的系统软件，
  - 它是计算机系统中**最基本的系统软件**。
- 简单来说，
  - 从程序的角度来讲，操作系统就是**对象+API（系统调用）**；
  - 从硬件的角度来讲，操作系统就是一个**C程序代码**

### 1.2 基本特征

- 并发：操作系统会**协调多个程序交替执行**
- 共享：系统**资源**可供多个**并发进程<u>互斥</u>地或<u>同时</u>地使用**
- 虚拟：操作系统将<u>内存、处理器</u>等**物理实体扩展映射为若干个逻辑对应物**
- 异步性：由于**资源有限**，**多进程**并发地**以不可预知的速度推进**

### 1.3 发展与分类

- <u>手工操作阶段</u>时，**人机速度矛盾**突出
- <u>多道批处理阶段</u>中，操作系统诞生，其中引入了**中断**技术，多个**程序并发执行**，资源利用率提高（但不能人机交互）
- <u>分时操作系统</u>**以<u>时间片</u>为单位<u>轮流</u>运行多个程序**，解决了**人机交互**问题（但不能优先响应紧急任务）
- <u>实时操作系统</u>能**优先响应紧急任务**，具有及时性和可靠性

### 1.4 运行机制和体系结构

- 运行机制

  > 两种处理器状态：

  - 核心态
    - 可执行**特权指令、非特权指令**
    - 运行**内核程序**
  - 用户态
    - 只能**非特权指令**
    - 运行**用户程序**

- 操作系统**内核/内核程序**可包含的功能：

  - **时钟**管理

  - **中断**处理

  - **原语**（设备驱动、CPU切换）

  - **资源**管理：进程管理、内存管理、设备管理

    > 根据是否包含**资源管理**相关功能，可分类为**宏内核、微内核**

### 1.5 中断和异常

- 中断的概念/本质

  - 发生中断就意味着**需要操作系统介入**，进入**核心态**，开展管理工作。

    > 中断是使<u>CPU从用户态进入核心态的唯一方式</u>。
    >
    > 本质是修改PSW，核心态下可以直接修改，用户态下只能通过中断修改。

  - 中断由运行在核心态下的**中断处理程序**处理

- 中断的分类

  - 内中断：**异常**
    - 系统调用等**陷入**（trap）
    
    - 硬件**故障**（fault）
    
      > 例如：缺页
    
    - 程序**终止**（abort）
    
      > 例如：除0
    
  - 外中断：**狭义的中断**
    - 外设请求
    
      > 例如：I/O操作完成
    
    - 人工干预
    
      > 例如：用户强行终止一个进程
  
  > “内外”是相对CPU而言

### 1.6 系统调用

- 系统调用的概念

  - 系统调用是**操作系统提供给应用程序调用的特殊函数**，可以用来获得操作系统的服务，在一情况下保证系统的稳定性和安全性

  > 系统调用需要特权指令，所以会引发陷入类型的**内中断**，从而使CPU从用户态进入**核心态**，执行系统调用相应服务程序。
  >
  > > **陷入指令是在用户态执行的**，该指令会引发内中断，从而进入内核态，然后再跳转到陷入处理函数，处理 

- 系统调用的功能

  - 进程管理
  - 存储器管理
  - 设备管理

- 库函数

  - 库函数是**对系统调用的封装**
  - 应用程序可以直接使用系统调用，也可以使用封装了系统调用的库函数。

## 2 进程管理

### 2.1 进程概述

- 进程的**概念**
  - 进程是**程序的一次执行过程**，是系统进行**资源分配**（和调度）的**基本单位**
  
    > 程序：指令序列
    >
    > **时钟中断**为多道程序设计模型的理论基础
  
- 进程的**组成**
  - 程序段
  - 数据段
  - **PCB**
    - 进程**描述**信息：进程标识符（**PID**）、用户标识符（**UID**）
    - 进程**控制和管理**信息：进程当前**状态**、进程当前**优先级**
    - **资源分配**清单：程序段和数据段的指针、键盘鼠标
    - **处理机**相关信息：各种**寄存器**值
  
- 进程的**组织方式**
  - **链接**方式：按照进程**状态**将PCB组织为多个**队列**
  - **索引**方式：按照进程**状态**将进程组织为多张**索引表**
  
- 进程的特征
  - 动态性（最基本）：程序的运行过程
  
  - 独立性：资源分配（和接受调度）的基本单位
  
      >   进程有自己独立的地址空间，有PCB
  
  - 并发性
  
  - 异步性
  
  - 结构性

### 2.2 进程的状态

- 为了**方便对各个进程的管理**，操作系统将进程合理地划分为几种**状态**

  - 三种基本状态
    - 运行态：占有CPU并**在CPU上运行**
    - 就绪态：**具备运行条件**但不占有CPU，从而不能运行
    - 阻塞态：因等待某一事件而暂时不能运行
  - 两种始末状态
    - 创建态：正在被**创建**并**分配资源**
    - 终止态：正在从系统中**撤销**并**回归资源**
  - 两种内存调度的挂起状态
    - 就绪挂起
    - 阻塞挂起

- 进程的状态转换称为**进程控制**，进程控制用**原语**实现

  > 原语的本质是**关中断**、执行某些操作、**开中断**

  - 创建：分配**资源**，申请并初始化**PCB**（设置为**就绪态**）并将其加入**就绪队列**
  - 撤销：找到对应**PCB**，剥夺**CPU**，**终止进程**（和子进程），归还**资源**，**删除PCB**
  - 阻塞：找到对应**PCB**，**保持运行现场**，**暂停**进程运行，将PCB设置为“**阻塞态**”并插入相应**阻塞队列**
  - 唤醒：在**阻塞队列**中找到对应**PCB**，将PCB从中移除并设置为“**就绪态**”、加入**就绪队列**
  - 切换：将当前进程**运行环境**信息存入PCB，移入相应队列，选择另一个进程，更新其PCB并恢复其运行环境

### 2.3 进程通信

- 进程通信的概念
  - 进程通信就是指**进程之间的信息交换**
  - 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的**内存地址空间相互独立**，但进程之间也需要**通信**。
- 进程通信的方法：
  - 共享存储：在内存中划分出一块**共享存储区**，由两个进程**<u>互斥</u>访问**
  - 消息传递：进程间以“**消息(Message)**”这种数据结构为单位，通过操作系统提供的**“发送消息/接收消息”两个原语**进行数据交换
    - 直接通信：消息直接挂到接收进程的**消息缓冲队列**上
    - 间接通信：消息要先发送到**中间实体（信箱）**中，因此也称”信箱通信方式“
- 管道通信：开辟**内存缓冲**区进行**半双工通信**

### 2.4 线程

- 线程的概念与特点

  - 线程是一个**基本的CPU执行单元**，是**CPU调度的基本单位**

    > 进程不再是**CPU调度的基本单位**了，但依然是**操作系统资源分配的基本单位**

    >   Linux系统的线程就是LWP(light weight process)，与Windows对线程的实现有较大差别

  - 线程**提升了系统的并发度**，并发所带来的**系统开销减少**，**数据通信和共享**方便

      >   因为线程是得到CPU时间片的基本单位，一个进程有更多的线程，得到CPU时间片的概率就会变大

- 线程的属性

  - 地位：**CPU调度的基本单位**，有自己的ID和**线程控制块**（TCB）

    > 注意，线程和进程都有**控制块**，但线程**没有独立地址空间**

  - 状态：三种基本状态和两种始末状态

  - 共享：同一进程的多个线程**共享进程资源**

      >   TCB中指向内存资源的**三级页表是相同的**

  - 切换：不同进程的线程切换可以引起进程切换，开销较大；同一进程的线程切换开销较小

- 线程的实现方式

  - 用户级线程：由应用程序通过**线程库**实现，由**应用程序负责管理**，在**<u>用户态</u>**下即可切换，**对操作系统透明**

  - 内核级线程：由**操作系统直接管理**，线程调度、切换需要在**核心态**下完成；只有内核级线程才是**处理机分配的基本单位**。

      >   对于Linux操作系统，线程对于**内核**来说其实就是**进程**，只不过是轻量级的，所谓TCB其实也是一种PCB。内核通过**LWP线程号**区分线程。

- 多线程模型

  - 多对一：多个用户级线程映射到一个内核级线程。开销小，效率高，并发度低
  - 一对一：一个用户级线程映射到一个内核级线程。并发能力强，成本高，开销大
  - 多对多模型：n用户及线程映射到m个内核级线程(n>=m)。平衡了**并发度**与**系统开销**

### 2.5 进程调度

#### 2.5.1 处理机调度

- 处理机调度的概念

  - 从进程**队列**中按照一定的算法选择一个进程并将**处理机分配**给它运行

- 处理机调度的层次

  - 作业调度/高级调度（后备队列）：

    > 只调入和调出一次

    - 调入：从外存后备队列中挑选作业分配资源，并建立相应进程（PCB）
    - 调出：作业运行结束后调出，撤销PCB

  - 内存调度/中级调度（挂起队列）：

    - 调出：将暂时不能运行的进程调至**外存**，进入挂起状态；PCB仍在内存，记录进程数据位置，加入**挂起队列**
    - 调入：将处于挂起状态并具备运行条件的进程重新调入内存

  - 进程调度/低级调度（就绪队列）：从**就绪队列**中选取**进程**将处理机分配给它，是最基本的调度，频率很高

- 处理机调度的方式：

  - 进程（调度）切换主要包括对**原进程数据的保存**和**新进程数据的恢复**
  - 需要考虑调度问题的时机：
    - 当前运行的进程**主动放弃**处理机（非抢占式和抢占式）
    - **新的进程进入**就绪队列（抢占式）
  - 不能调度与切换的时机：
    - 处理**中断**
    - **内核程序临界区**
    - **原子操作**

#### 2.5.2 调度算法

*调度算法评价指标：*

- CPU利用率：CPU“**忙碌**”的时间占**总时间**的比例
- 系统吞吐量：单位时间内完成作业的数量
- 周转时间：
  - 从**作业被提交给系统**开始，到**作业完成**为止的时间间隔
  - 带权周转时间：**周转时间**除以作业实际**运行时间**
- 等待时间：进程/作业处于**等待处理机**状态时间之和
- 响应时间：从用户提交请求到**首次产生响应**所用的时间

---

*注重**周转时间**调度算法：*

- 先来先服务（FCFS）：按照作业/进程**到达的先后顺序**进行服务（非抢占）

  > **等待时间**最长的优先得到服务

  - 优点：公平、算法实现简单

  - 缺点：对长作业/进程后面的短作业/进程不利

    > FCFS算法**对长作业有利**，对短作业不利
    >
    > > 注意，这里的长指的是**CPU计算的时间长**，即CPU密集型，而不是指I/O时间很长（即I/O密集型），毕竟I/O阻塞的时候是会放弃CPU的

- 短作业/进程优先（SJF/SPF）：**最短**的作业/进程优先得到服务（抢占、非抢占）

  > **运行时间**最短的优先得到服务

  > 抢占式版本的又称“最短剩余时间优先算法（SRTN）”

  - 优点：平均等待时间和平均周转时间较短
  - 缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。

- 高响应比优先（HRRN）：**响应比**最高的作业/进程优先得到服务（非抢占）

  > **等待时间**长、**运行时间**短的优先得到服务

  > $响应比=\frac{等待时间}{要求服务时间}+1$

  - 优点：综合考虑了等待时间和运行时间，避免短作业长时间等待和长作业饥饿的问题

---

*注重**响应时间**的调度算法：*

> 更适应于交互式系统

- 时间片轮转调度算法（RR）：按照到达顺序（就绪队列）**轮流**让**各进程**执行一个时间片，未执行完则重新放到队列尾排队（抢占）

  - 优点：公平；**响应快**，适用于**分时操作系统**

  - 缺点：高频率进程切换，开销较大；无法区分任务**紧急程度**

- 优先级调度算法：选择**优先级最高**的作业/进程（抢占、非抢占）

  - 优点：可区分紧急程度和重要程度，适用于**实时操作系统**。

  - 缺点：低优先级可能饥饿


  > 设置优先级的例子：
  >
  > - 系统进程高于用户进程
  >
  > - 前台进程高于后台进程
  >
  > - I/O繁忙型（I/O密集型）进程高于计算型（CPU密集型）进程
  >
  >   > I/O设备和CPU可以并行，优先让I/O繁忙设备运行，可以让I/O设备更早投入工作，提升资源利用率和系统吞吐量
  >
  > - 等待时间长或刚运行不久的进程优先级较高
  >
  > - 运行时间长的进程或刚运行完的进程优先级较低

- 多级多反馈队列调度算法：（抢占）
  - 算法规则
    - 设置多级就绪队列，**优先级**从高到低，**时间片**从小到大
    - 新进程先进入**高优先级**队列，用完时间片进入**次高优先级**队列，若已经是最低优先级则回到队尾
    - 高优先级队列为空时才会给次高优先级分配时间片
  - 优点：
    - 公平（FCFS的优点）
    - 短进程周转时间小（SPF的优点）
    - 响应快（RR的优点）
    - 可设置优先级
  - 缺点：会导致饥饿

### 2.6 进程互斥与同步

#### 2.6.1 互斥与同步的概念与软件硬件实现

- 概念

  - 同步亦称**直接制约**关系，是指多个进程需要**协调工作次序**而产生制约关系。
  - 互斥亦称**间接制约**关系。是指多个进程**对临界资源的访问是互相排斥**的。

- 实现原则

  - 空闲让进
  - 忙则等待
  - 有限等待
  - 让权等待

- 软件实现

  - 单标志法：每个进程进入临界区的权限由**其他进程在使用完临界区后**赋予

  - 双标志检查法：

    - 先检查：先**通过标记检查其他进程**是否要进入临界区，再**标记自己**想进入临界区
    - 后检查：先**标记自己**想进入临界区，再**通过标记检查其他进程**是否要进入临界区

    > 会因**并发进程的异步性**出现问题

  - Peterson算法

    1. 标记自己想进入临界区
    2. 表示“谦让”：将turn轮流标记设置为其他进程
    3. 通过标记检查，如果有其他进程想进且没有轮流标记没有到自己，则等待

- 硬件实现

  - 中断屏蔽：在访问临界区前后**关开中断**
  - TestAndSet指令（TS、TSL）：访问临界区前**“上锁”并检查之前是否已经有锁**（这个操作由硬件完成，不可中断），若有则循环重复，若无则访问；**访问临界区后”解锁“**
  - Swap指令（Exchange、XCHG）：将当前锁的状态（lock）换到自己手上（old），看手上的状态（old）是否无锁，若无则可以访问，若有则循环重复；**访问临界区后”解锁“**

#### 2.6.2 信号量机制与经典问题

- 信号量基础知识

  - 信号量就是**表示某种系统资源数量**的变量。

  - wait和signal原语，相当于资源的“申请”和“释放”

    > 原语是**执行时不可被中断**的特殊程序（由开中断、关中断实现）
    >
    > 记录型信号量的wait原语内部有用到block原语，signal原语内部有用到wakeup原语
    
  - 用于实现**进程互斥**：设置**互斥信号量**（mutex），在临界前后执行PV操作

  - 用于实现**进程同步**：设置**同步信号量**，前V后P

- 经典问题及其解决思路

  - 生产者与消费者问题
    - 互斥：缓冲区
    - 同步：缓冲区空时生产者先消费者后；缓冲区满时消费者先生产者后

  - 多生产者与消费者问题
    - 互斥：缓冲区
    - 同步：缓冲区空时先生产某种产品对应消费者才能消费；缓冲区满时先消费才能生产

  - 吸烟者问题
    - 特点：有可以生产**多种产品**的单生产者、有“轮流”的要求
    - 互斥：桌子（可以不设置）
    - 同步：桌子空时先放才能拿；桌子满时先拿才能放

  - 读者-写者问题
    - 特点：读写互斥但读之间不互斥
    - 写-写互斥：rw锁
    - 写-读互斥：rw锁
    - 读-读不互斥：第一个来读的加锁，最后一个读完的解锁

        >   根据count变量加解rw锁，并通过mutex锁保证对count的更改和判断是不可中断的
    - 读-写公平：再加一个w锁约束读进程**对count的检查和对rw锁的加锁**

  - 哲学家进餐
    - 特点：构造出了经典的**循环等待**场景
    - 互斥：同一根筷子
    - 防止死锁：让哲学家**拿起一双筷子的操作是原子性的**


#### 2.6.3 管程

- 管程的概念

  - 管程是一种特殊的**软件模块**，由**共享数据结构**和**对数据结构的操作（函数）**组成。

- 管程的特点

  - 管程**每次只允许一个进程**执行对数据结构进行**操作**

    > 只能通过**管程内部定义的过程/函数**来操作

- 管程的实现

  - 互斥特性由**编译器**负责实现
  - 同步特性由**条件变量**和**等待唤醒操作**实现

#### 2.6.4 死锁

*概念：*

- 在并发环境下，各进程因**竞争资源**而造成的一种<u>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进</u>的现象

---

*死锁的产生：*

- 必要条件

  - **互斥**条件：争抢互斥使用的资源

  - **不剥夺**条件：进程已经占有的资源在使用完之前不能被其他进程抢走

  - **请求和保持**条件：进程**请求新资源**的同时**保持原占有资源**不放

  - **循环等待**条件：存在进程资源的循环等待链

      >   前三点很多场景都满足，第四点是判断的重点

- 发生时机

  > 对不可剥夺资源的不合理分配可能导致死锁

  - 对系统资源的竞争
  - 进程推进顺序非法
  - 信号量的使用不当

---

*死锁的处理策略：*

> - 忽略
> - 检测与解除
> - 避免
> - 预防
>
> > 按系统并发性从大到小排序的4类处理策略

- <u>**预防**死锁</u>

  - 破坏**互斥**条件：把互斥资源改造成共享使用（如SPOOLing技术）

    - 缺点：可行性不高，很多时候**无法破坏互斥条件**

  - 破坏**不剥夺**条件：

    - 方案一：申请的资源得不到满足时，立刻释放占有的所有资源

    - 方案二：申请的资源被其他进程占用时，由操作系统协助剥夺

      > 考虑优先级

    - 缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿

  - 破坏**请求和保持**条件：运行前分配好所有需要的资源（**静态分配**），一直保持直到运行结束

    - 缺点：资源利用率低；可能导致饥饿

  - 破坏**循环等待**条件：给**资源编号**，按编号从小到大的顺序申请资源（顺序资源分配）

    > 原理：已经持有大编号资源的进程不可能回来申请小编号的资源。任意时候总有一个进程拥有的资源编号最大，那么从该进程出发一定有**安全序列**，也就是任意时刻都有安全序列。

    - 缺点：不方便增加新设备；进程使用资源的顺序与编号顺序可能不同，导致资源浪费；用户编程麻烦（必须按编号顺序申请资源），程序可移植性差。

- **避免**死锁

  - 银行家算法思想：在进程申请资源时，预判这次分配后会不会进入**不安全状态**，如果会则阻塞进程

    - 不安全状态：找不到安全序列
    - 安全序列：系统按照这个序列分配资源，则每个进程都能顺利完成

  - 银行家算法步骤

    1. 检查此次申请$Request$是否超过之前声明的**最大需求数**$Need$，如果超过认为**出错**

       > $Need=Max-Allocation$

    2. 检查系统剩余可用资源$Available$是否能**满足这次请求**$Request$，不能则**阻塞进程**

    3. **试探分配**，更改数据结构

    4. 用**安全性算法**检查分配后是否会导致系统进入不安全状态

  - 安全性算法步骤

    - 检查当前剩余可用资源$Work$是否能满足某个（某些）进程的最大需求，如果可以则将该进程（这些进程）加入**安全序列**，并回收其全部资源
    - 重复上述过程，直至找到完整的**安全序列**或$Work$无法满足现有的任何进程

- 死锁的**检测**：

  - 能检测的前提：
    - 有某种**数据结构**保存资源的**请求和分配信息**
    - 有一种检测系统是否进入死锁状态的**算法**
  - 数据结构：资源分配图
    - **进程**结点：对应一个进程
    - **资源**结点：对应一类资源，结点中可以记录该类资源**总量**
    - **进程**结点指向**资源**结点的边：进程**还需要**申请的资源（每条边代表一个）
    - **资源**结点指向**进程**结点的边：已经分配给进程的资源（每条边代表一个）
  - 算法：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统死锁（死锁定理）
    - **能执行**的进程（已申请到**所有所需资源**）或能**分配现有资源**使之**能执行**的进程先执行，执行完后归还系统资源，消除相应的边
    - 继续寻找能执行的进程，直到不再能找到或消除了所有的边
    - 如果能消除所有边，就称该资源分配图是可完全简化的

- 死锁的**解除**

  - 资源剥夺
  - 撤销进程
  - 进程回退

## 3 内存管理

### 3.1 内存管理概述

*内存和地址概述：*

-   <u>内存概述</u>

    -   概念：内存是用于**存放数据的硬件**。

    -   主要应用：程序要放到**内存**中才能被**CPU**直接执行。

    -   组织形式：内存通常从0开始顺序编址，每号地址对应一个存储单元

        -   按字节编址：每个存储单元大小为1字节

        -   按字编址：每个存储单元大小为1个字

            >   字长由计算机决定

-   <u>地址与地址空间概述</u>

    -   虚拟地址：用户编程时使用的地址，一般指**段名+段内相对地址**

    -   逻辑地址/相对地址：用户编程时使用的地址，一般指**段内相对地址**

    -   物理地址/绝对地址：实际物理内存的地址

    -   逻辑地址空间：一般指各**程序段**所有**逻辑地址**的集合

        >   实际应用中，虚拟地址与逻辑地址常常不加区分

    -   线性地址空间：**CPU地址总线**可以访问的所有地址集合

    -   物理地址空间：实际可访问的**物理内存地址**集合

-   <u>编译、链接、装入</u>

    -   概念

        -   编译：<u>编译程序</u>将**用户源代码**编译成若干个**目标模块**

            >   编译时会形成相对该模块的逻辑地址

        -   链接：<u>链接程序</u>将各目标模块、**库函数**链接在一起，形成的**装入模块**

            >   装入模块就是一种**可执行模块/文件**
            >
            >   链接器完成重定位，形成整个程序完整的逻辑地址空间

        -   装入：<u>装入程序</u>将装入模块装入内存运行

    -   链接的三种方式

        -   静态链接：在**程序运行前**将各目标模块、库函数链接成**完整的装入模块**

        -   装入时动态链接：在各目标模块**装入内存时**链接库函数

        -   运行时动态链接：程序**运行时需要**目标模块再链接库函数

            >   便于库函数的**修改和更新**，便于目标模块的**共享**

    -   装入的三种方式

        -   绝对装入：直接按照编译时产生的**绝对地址**将程序和数据装入内存

            >   绝对装入只适用于**单道程序环境**

        -   静态重定位：又称可重定位装入，指令和数据使用**逻辑地址**，由**装入程序**在装入时完成逻辑地址到**物理地址**的转换

            >   静态重定位装入时必须分配**全部所需空间**，模块装入内存后，运行期间**无法申请其他内存、无法移动**

            >   用于早期**多道批处理系统**

        -   动态重定位：又称动态运行时装入，指令和数据使用**逻辑地址**，在程序**运行时**借助**重定位寄存器**完成逻辑地址到**物理地址**的转换

            >   重定位寄存器/基址寄存器：存放装入模块的**起始物理地址**
    
            >   动态重定位允许**分配不连续内存**，允许动态地**部分装入和申请内存**，允许模块**在内存中移动**，便于**共享和虚拟内存**的实现

---

*内存管理的主要内容：*

- <u>内存的分配与回收</u>：操作系统负责**内存空间的分配与回收**

  -   连续分配
      -   单一连续分配

      -   固定分区分配

      -   动态分区分配

  -   非连续分配
      -   基本分页存储管理

      -   基本分段存储管理

      -   基本段页式存储管理

- <u>内存空间的扩充</u>：操作系统需要提供某种技术从逻辑上**对内存空间进行扩充**

  -   覆盖技术

  -   交换技术

  -   虚拟存储技术

- <u>地址转换</u>：操作系统需要提供**地址转换功能**，负责程序的**逻辑地址**与**物理地址**的转换

- <u>存储保护</u>：操作系统需要提供**内存保护**功能，保证各进程在各自存储空间内运行，互不干扰

  -   采用**上下限寄存器**，存放进程的**上下限地址**

  -   采用**基址寄存器和界地址寄存器**，分别存放**起始物理地址**和**最大逻辑地址**

      >   基址寄存器也称**重定位寄存器**，界地址寄存器也称**限长寄存器**

### 3.2 连续分配与地址转换

```
连续分配与地址转换
	- 单一连续分配
	- 固定分区分配
	- 动态分区分配
```

> 连续分配：为用户进程分配的只能是**连续的内存空间**

*单一连续分配：*

-   <u>内存划分</u>：单一连续分配方式中内存被分为**系统区和用户区**

    -   系统区：位于内存的低地址部分，存放**操作系统相关数据**
    -   用户区：存放**用户进程相关数据**，只允许**一道用户程序独占**整个用户空间

-   <u>单一连续分配的优点</u>：

    -   实现简单
    -   无外部碎片
    -   可以用覆盖技术扩充内存
    -   不一定需要内存保护

-   <u>单一连续分配的缺点</u>：

    -   只能用于单用户、单任务操作系统

    -   有内部碎片

        >   内部碎片：分配给进程的内存空间中没有被利用的部分

    -   存储器利用率极低

---

*固定分区分配：*

-   将整个用户空间划分为若干个**固定大小的分区**，每个分区中装入一道作业，支持**多道程序**并发
-   <u>分区**策略**</u>：
    -   分区大小相等：缺乏灵活性，适合用于一台计算机控制多个相同对象的场合
    -   分区大小不等：增加了灵活性，可以根据不同大小的进程需求划分空间
-   <u>**分区说明表**</u>：用于管理分区，记录各分区的分配与回收
    -   字段：分区号、分区大小、起始地址、状态（已分配和未分配）
-   <u>固定分区分配**优缺点**</u>：
    -   优点：实现简单，无**外部碎片**
    -   缺点：
        -   可能无法满足**大进程**需求，不得不采用低性能的**覆盖**技术
        -   会产生**内部碎片**，内存利用率低

---

*动态分区分配：*

- 又称为**可变分区分配**，不预先划分内存分区，而是在进程装入内存时**根据进程大小动态建立分区**，因此系统分区的**大小和数目是可变的**。

-   <u>分区分配中的**数据结构**</u>
    
    -   空闲分区表：
        -   字段：分区号、分区大小、起始地址、状态（已分配和未分配）
    -   空闲分区链：
        -   将每个单独的内存分区视作链表的一个结点
        -   结点的起始部分：前向指针、分区大小等信息
        -   结点的末尾部分：后向指针
    
-   <u>分配与回收的**具体操作**</u>
    
    -   分配：根据分配算法选择空闲区，再**更新空闲分配表**
        -   只**占用部分**空闲区：**修改**表项
        -   刚好**填满**空闲区：**删除**表项
    -   回收：回收进程并**更新空闲分配表**
        -   有相邻空闲分区：
            - 只有前面有或只有后面有：修改表项
            - 前后均有：合并表项
        -   无相邻空闲分区：
            -   新增表项
    
- **<u>动态分区分配算法</u>**：

  -   首次适应算法（First Fit）
      -   思想：从**低地址向高地址**查找第一个满足大小的空闲分区
      -   实现：空闲分区表以**地址递增**次序排列，每次分配时顺序查表
      -   优点：综合性能好；对空闲分区表操作简单，**算法开销小**；可以保留高地址部分大空闲区
      -   缺点：低地址部分易产生**外部碎片**

  -   最佳适应算法（Best Fit）
      -   思想：优先使用**更小的空闲区**分配
      -   实现：空闲分区表按**容量递增**次序链接，每次分配时顺序查表
      -   优点：保留更多**大空闲区**，满足大进程需求
      -   缺点：容易残留更多**外部碎片**；回收分区后要**排序**空闲分区表，**算法开销大**

  -   最坏适应算法（Worst Fit）
      -   思想：优先使用**更大的空闲区**分配
      -   实现：空闲分区表按**容量递减**次序链接，每次分配时顺序查表
      -   优点：可以减少**外部碎片**
      -   缺点：难以保留**大空闲区**，不利于大进程需求；回收分区后要**排序**空闲分区表，**算法开销大**

  -   邻近适应算法（Next Fit）
      -   思想：在**首次适应**算法的基础上，每次从**上次查找结束**位置开始**循环查找**
      -   实现：空闲分区表以**地址递增**次序排列成**循环表**，每次分配时**从上一次位置开始循环查表**
      -   优点：对空闲分区表操作简单，**算法开销小**；减少低地址部分的**外部碎片**
      -   缺点：难以保留**大空闲区**，不利于大进程需求

- <u>动态分区分配的**优缺点**</u>

  - 优点：无**内部碎片**，分配出的内存利用率高

  - 缺点：有**外部碎片**，会产生过小的空闲分区而难以分配

    > 可以通过**紧凑（拼凑，Compaction）**技术解决外部碎片，这需要结合**动态重定位装入**移动进程块位置，并修改PCB中的进程起始地址，以及重定位寄存器/基址寄存器


### 3.3 分页分段与地址转换

> 离散分配：为用户进程分配的可以是**分散的内存空间**

*基本分页存储管理：*

- <u>基本思想</u>：把**内存**划分成相等的**分区**，再按照同样大小将**进程**拆分成**进程块**

  - 划分出的内存分区称为**页框**，或页帧、内存块、物理块；

    每个页框都有编号，称为**页框号**，或页帧号、内存块号、物理块号

  - 与页框大小相等的进程块称为**页**或页面；

    每个页都有编号，称为**页号**

  > 进程被拆分的最后一个页面可能小于页框大小，因此页框不能太大，否则会产生过大的**内部碎片**。但这种方式一定不会产生**外部碎片**。

- <u>页表与地址结构</u>

  - 页表：操作系统为每个进程建立一张页表，记录**进程每个页面在物理内存中的内存块号**

    > 页表本身也存储于内存，单级页表**顺序存储**，多级页表可以**离散存储**

  - 页表项：每个页表项**长度相等**，由页号和块号组成

    - 页号：进程页号，隐含的，相当于逻辑上的数组**索引**
    - 块号：进程页实际存放到的**内存块号**。其位数由**内存块的数量**决定

    > **页表项的大小**尽量能整除页框大小，这样存放页表时可以减少**内部碎片**

  - 逻辑地址结构：

    - **页号P**：逻辑地址所在页的**页号**。页号=逻辑地址/页面长度

      利用**页表**，以页号作为**索引**，查寻块号，计算出进程页在内存中的**起始地址**

      页号P的位数对应于进程的**最大页面数**

    - **页内偏移量W**：逻辑地址在页内的**偏移量**。页内偏移量=逻辑地址%页面长度

      页内偏移量W的位数对应于**页面大小**

    > 页式管理中地址是**一维**的，程序员只要给出**一个逻辑地址助记符**就可以自动计算出**物理地址**

  - **多级**页表/页目录表：将页表**拆分并离散存放**至内存，并用页目录表统计

    > 单级页表需要**连续存储**至内存，不符号离散分配的思想

    - 页目录表的表项：

      页号：某级页号

      块号：“页表块”存放到的内存块号

    - 对应的逻辑地址结构：

      页号：可被拆分成多级页号

      页内偏移量：与单级页表相同

    - 多级页表的思想在虚拟存储技术中有所应用

  - **快表**：又称联想寄存器（TLB, Translation Look-aside ），是一种**高速缓存**，用于存放最**近访问过的若干页表项**，以加速地址变换。相对而言，内存中的页表常称为**慢表**

    > 单级页表记录了所有页的信息，没有考虑**局部性原理**

    > 快表具体的结构与算法参见计算机组成原理

- <u>地址变换机构</u>

  - 页表寄存器（PTR）

    - 存放页表在内存中的**起始地址F和页表长度M**
    - F和M会存放于PCB中，在进程执行时存入PTR

  - 地址变换过程

    1. 根据逻辑地址算出**页号P、页内偏移量W**

    2. 根据**页号**得到**进程页起始地址**

       0. （**匹配快表**：若命中快表表项，可直接得到**进程页起始地址**，若未命中则需**访存**）

       1. **越界检查**：将**页号**与PTR中的**页表长度**对比，检查是否合法

       2. **索引计算**：根据**页表起始地址、页表项长度、页号**计算出**页表项地址**

          > 这也是**数组**索引访问的计算原理

       3. **得到始址**：由页表项得到进程页所在**内存号块**，进而计算出**进程页起始地址**

       4. （**更新快表**：将页表项存入快表）

    3. 根据**进程页起始地址和页内偏移量**计算出**物理地址**

  - 页表与访存：

    - 在没有命中快表的情况下：n级页表的访存次数为n+1次，前n次是查找页表，最后一次是访问数据

      > 不考虑多级快表

    - 在命中快表的情况下：只需一次访问内存数据（查询快表访问的是缓存）


---

*基本分段存储管理：*

- <u>基本思想</u>：

  - 进程按**逻辑**关系划分为若干个大小可以不相等的**段**，每段都有一个**段名和段号**，从0开始编址

    > 编程更方便，程序可读性更高

  - 以段为单位分配内存，段内连续，各段之间可以离散

- <u>段表与地址结构</u>：

  - 段表：操作系统为每个进程建立一张段映射表，记录各**逻辑段在物理内存中存放位置**

  - 段表项

    - 段号：进程逻辑段的段号，隐含的，相当于逻辑上的数组**索引**
    - 段长：逻辑段的长度。位数与**段内地址**位数相同。
    - 逻辑段基址：逻辑段在物理内存中存放的**起始位置**。位数由物理内存**存储单元个数**决定

  - 逻辑地址结构：段号+段内地址

    - 段号：逻辑地址所在段的段号。段号=逻辑地址/最大段长

      段号的位数对应于进程最多可以分几个段

    - 段内地址：逻辑地址在段内的偏移量。段内地址=逻辑地址%最大段长

      **段内地址**位数决定了最大**段长**

    > 段式管理中地址是**二维**的，程序员要同时给出**段名和段内地址**才可以计算出**物理地址**

- <u>地址变换机构</u>：

  - 段表寄存器：
    - 存放段表在内存中的**起始地址F和段表长度M**
    - F和M会存放于PCB中，在进程执行时存入段表寄存器
  - 地址变换过程：
    1. 根据逻辑地址算出**段号、段内地址**
    2. 根据**段号**得到**进程逻辑段起始地址**
       1. **越界检查**：将**段号**与段表寄存器中的**段长度**对比，检查是否合法
       2. **索引计算**：根据段表起始地址、段表项长度、段号计算出**段表项地址**
       3. **越界检查**：由段表项得到**段长**，检查**段内地址**是否合法
       4. 得到始址：由段表项**进程逻辑段起始地址**
    3. 根据**进程逻辑段起始地址和段内地址**计算出**物理地址**
  - 段表与访存：
    - 一次访存查段表，一次访存目标数据
    - 也可以引入快表减少访存

- <u>分段分页对比</u>：

  - 从地址空间的角度对比：
    - 页是信息的**物理单位**，对用户不可见，分页进程的地址空间是一维的。页长固定，由系统决定。
    - 段是信息的**逻辑单位**，对用户可见，分段进程的地址空间是二维的。段长不固定，由程序员决定。
  - 从目的的角度对比：
    - 分页目的是实现**离散分配**，提高内存利用率，是系统管理的需要。没有外部碎片，会产生少量页内碎片。
    - 分段目的是将进程划分为逻辑段，方便程序员编程。会产生外部碎片，且段长过大不方便分配
  - 从共享的角度对比：
    - 分段可以拆分逻辑模块，比分页更容易实现**信息的共享和保护**。
    - 分段可以灵活拆分**可重入代码和不可重入代码**，保证**数据一致性**，实现安全共享。分页则不够灵活。

---

*段页式存储管理：*

- <u>基本思想</u>：

  - 先将进程拆分成**逻辑段**，再将各**逻辑段分页**。分段对用户可见，分页对用户不可见。
  - 在**用户进程**这边，保留**段的逻辑划分**；在**系统内存**这边，保留**页的管理方式**。

- <u>段表、页表与地址结构</u>：

  - 逻辑地址结构：

    - 段号：逻辑地址所在段的段号。段号=逻辑地址/最大段长

      段号的位数对应于进程**最多可以分几个段**

      > 保留分段存储管理的**段号**，将**段内地址**拆分成页号和页内偏移量。
      >
      > 段内地址=逻辑地址%最大段长

    - (段内)页号：逻辑地址在**段内所在页**的页号。(段内)页号=段内地址/页面长度

      (段内)页号的位数对应于**每个段最多有多少页**

    - 页内偏移量：逻辑地址在**段内所在页**中的偏移量。页内偏移量=段内地址%页面长度

      页内偏移量的位数对应于**页面大小**

    > 段页式管理中地址是**二维**的，程序员要同时给出**段名和段内地址**才可以计算出**物理地址**

  - 段表与页表结合：

    - 段表项：段表项的内容是**页表信息**

      段号：逻辑地址所在段号，隐含的，相当于逻辑上的数组索引

      页表长度：逻辑段的页表的长度。位数与(段内)页号的位数相同

      页表块号：逻辑段的页表实际存放到的内存块号，其位数由**内存块的数量**决定

    - 页表项：页表变化不大，但一个进程可以有多个页表

      页号：逻辑段页号，隐含的，相当于逻辑上的数组**索引**

      块号：逻辑段页实际存放到的**内存块号**。其位数由**内存块的数量**决定

  - 段页表与访存

- <u>地址变换机构</u>：

  ```mermaid
  graph LR
  逻辑地址-->段号
  逻辑地址-->页号
  逻辑地址-->页内偏移量
  段号--段表-->页表-->基址
  页号--页表-->基址
  基址-->物理地址
  页内偏移量--基址-->物理地址
  ```

  - 段表寄存器
    - 存放段表在内存中的**起始地址F和段表长度M**
    - F和M会存放于PCB中，在进程执行时存入段表寄存器
  - 地址变换过程
    1. 根据逻辑地址算出**段号、页号、页内偏移量**
    2. 根据**段号、页号**得到**进程逻辑段页起始地址**
       1. **段号越界检查**：将**段号**与段表寄存器中的**段长度**对比，检查是否合法
       2. **段表项索引计算**：根据段表起始地址、段表项长度、段号计算出**段表项地址**
       3. **页号越界检查**：由段表项得到**页表长度**，检查**(段内)页号**是否合法
       4. **得到逻辑段页表始址**：由段表项得到逻辑段页表所在**内存块号**，进而计算出逻辑段页表起始地址
       5. **页表项索引计算**：由逻辑**段页表起始地址、页表项长度、逻辑段页号**计算出**页表项地址**
       6. **得到逻辑段页始址**：由页表项得到逻辑段页所在**内存号块**，进而计算出**逻辑段页起始地址**
    3. 根据**进程逻辑段页起始地址和页内偏移量**计算出**物理地址**
  - 段页表与访存
    - 一次查段表，一次查页表，一次访问目标单元
    - 可引入快表减少访存

### 3.4 覆盖交换和虚拟存储

*覆盖和交换技术：*

<u>覆盖技术</u>：

- 基本思想：将程序分为多个段，**常用的段常驻内存**，不常用的段在需要时调入内存且**互相覆盖**

- 实现方式：将内存分为固定区和覆盖区，并合理划分程序的**调用结构**

  - **固定区**：常驻内存的段放在固定区，调入后直接程序结束才调出。

    在调用结构中位于顶层的模块**独占固定区**

  - **覆盖区**：不常用的段在用到时调入覆盖区，用不到时调出

    在调用结构中位于同一层次但不会同时调用的模块**共享覆盖区**

- 优缺点：

  - 优点：实现了内存扩充，提高内存利用率和运行效率
  - 缺点：必须由程序员**声明覆盖结构**，操作系统完成自动覆盖，对用户不透明，增加编程负担

<u>交换技术</u>：

- 基本思想：**进程的中级调度/内存调度**，将内存中暂时无法运行的进程**换至外存**，把外存中具备运行条件的进程**换入内存**

- 实现方式：

  - 磁盘分为文件区和对换区：

    **文件区**存放文件，追求**存储空间的利用率**，因而采用**离散分配**；

    **对换区**只占磁盘空间的小部分，用于存放换出的进程数据，追求**换入换出速度**，因而采用**连续分配**

  - 交换调度策略：

    **交换时机**：系统负荷大、内存空闲不足时，例如进程经常发生缺页现象时

    **调度策略**：可换出阻塞进程、优先级低的进程，为防止抖动，还可以考虑进程在内存驻中的留时间……

  > 注：进程的**PCB一定常驻内存**，内存调度时不会被换出

- 覆盖与交换的区别
  - 覆盖是在**同一个进程**中的
  - 交换是在**不同进程（或作业）**中的

---

*虚拟内存的思想*

:star:<u>传统存储管理方式的特点</u>

- **一次性**：作业必须**一次性全部装入**内存才开始运行

  - 容易导致**大作业无法运行**
  - 内存无法容纳太多作业，**多道程序并发度下降**

- **驻留性**：作业装入内存后会**一起驻留直到运行结束**

  > 事实上只要访问一小部分数据就可以正常运行

  - 内存中会驻留许多暂时用不到的数据，**降低内存的利用率**

:star:<u>虚拟内存的定义和特征</u>：

- 虚拟内存的概念：程序装入内存时，可以只装入运行**需要用到的模块**，暂时用不到的模块可以换出至外存，待需要时再调入内存，这样在用户看来就似乎有一个比实际内存更大的内存

  > 是内存在逻辑上的扩充，体现了**操作系统的虚拟性**

- 虚拟内存的特征：

  - 多次性：允许作业分多次调入内存
  - 对换性：作业无需常驻内存，允许根据需求换入换出
  - 虚拟性：从逻辑上扩充了内存容量

---

*虚拟内存的实现*

> 虚拟内存的要在**离散分配**方式的基础上实现，分页分段均可，下面以分页为例

:star:<u>请求调页</u>

- 页表机制

  > 在基本分页存储管理页表的基础上，添加四个新的字段

  - **状态位**：是否已经调入内存
  - **访问字段**：可记录最近被访问的次数，或上次访问的时间，供置换算法参考
  - **修改位**：页面调入内存后是否被修改过
  - **外存地址**：页面在外存中的存放位置

- 缺页中断机构

  - 缺页中断的概念：进程当前指令**访问的目标页未调入内存**而产生的中断，属于**内中断**中的故障（fault）
  - 工作流程：
    1. 找到页表项后检查**状态位**，若页面未调入内存则产生**缺页中断**，阻塞当前进程
    2. 运行操作系统的**缺页中断处理程序**，将目标页面调入内存并更新**页表**
       1. 保留CPU现场
       2. 从外存中找到缺页
       3. 若内存中没有空闲块，则需要运行**页面置换**算法淘汰一个页面；若被调出的页面修改过，还需要**写回外存**
       4. CPU读入缺页，将缺页调入内存
       5. 更新页表和快表
    3. **唤醒**因缺页中断阻塞的进程，放入**就绪队列**，让其重新查表

- 地址变换机构：总体上与基本分页存储管理相同，增加了几个步骤

  - 请求调页：访问页表时若发现页不在内存，要产生缺页中断请求调页
  - 页面置换：调入前若发现内存没有空闲块，需要进行页面置换
  - 修改页表：调入缺页后修改页表，并即时增加或删除快表

:star:<u>页面置换</u>

- 页面置换算法

  - 最佳置换算法（OPT，Optimal）

    - 算法思想：每次淘汰**之后最长时间内不再被访问**的页面
    - 算法实现：需要提前知道页面访问序列，淘汰时计算内存中各页面下一次出现的位置，最后一个出现的被淘汰
    - 算法评价：可以保证最低的缺页率。但该算法无法实现，因为操作系统无法预判**页面访问序列**

  - 先进先出置换算法（FIFO）

    - 算法思想：每次淘汰**最早调入内存**的页面

    - 算法实现：将调入内存的页面按调入顺序排成队列，每次淘汰队头页面

      > 队列的最大长度取决于操作系统为进程分配了多少个内存块

    - 算法评价：实现简单；会产生Belady异常，没考虑局部性原理，性能差

      > Belady异常：为进程分配的内存块数增加时，**缺页次数不减反增**

  - 最近最久未使用置换算法（LRU，least Recently Used）

    - 算法思想：每次淘汰最近最久未使用的页面

    - 算法实现：用页表项的访问字段记录**自上次被访问以来所经历的时间t**，每次淘汰t值最大的页面

      > 做题时可以从当前访问页开始逆向检查访问序列，最后一个出现的就是要淘汰的

    - 算法评价：性能好；实现困难，需要专门的硬件支持，开销大

      > 性能最接近OPT

  - 时钟置换算法/最近未用算法（NRU，Not Recently Used）/CLOCK算法

    - 简单CLOCK算法的实现：

      将内存中的页面链接成一个循环队列，某页被访问时，将其页表项的访问位置1；

      需要淘汰页面时，从上一次淘汰的位置或其下一个位置开始，遍历队列循环检查访问位，若为0则直接换出，若为1则将其置为0；

      这样最多两轮扫描，就可以淘汰一个页面

    - 改进CLOCK算法的实现：

      > 思想：在近期访问情况相近的情况下，优先淘汰**没有修改**的页面，以减少IO次数

      将内存中的页面链接成一个循环队列，某页被访问时，将其页表项的访问位置1，某页被修改时，将其页表项的修改位置1，初始为0，用$(访问位,修改位)$表示各页面状态。

      需要淘汰页面时，从上一次淘汰的位置或其下一个位置开始，遍历队列循环检查$(访问位,修改位)$：

      第一轮寻找第一个$(0,0)$，找到则替换，不修改标志位；

      第二轮寻找第一个$(0,1)$，找到则替换，将扫描过的访问位置为0；

      第三轮寻找第一个$(0,0)$，找到则替换，不修改标志位；

      第四轮寻找第一个$(0,1)$，找到则替换。

      这样最多四轮扫描，就可以淘汰一个页面

    - 算法评价：开销小，性能不错

- 页面置换策略

  - **驻留集**：请求分页存储管理中给进程分配的物理块的集合

    - 在虚拟存储中，驻留集大小一般小于进程总大小
    - 若驻留集太小，会导致缺页频繁；若驻留集太大，会降低多道程序并发度

  - 页面分配与置换方式

    - **固定分配**：进程运行期间驻留集大小不变
    - **可变分配**：进程运行期间驻留集大小可变
    - **局部置换**：进程缺页时只能置换属于自己的物理块（由操作系统分配的）
    - **全局置换**：进程缺页时可以利用操作系统的空闲块，也可以窃取其他进程的物理块

  - 三种置换策略

    - **固定分配局部置换**

      可以根据**进程优先级**等信息分配内存块数

      > 缺点：很难确定合理的分配数

    - **可变分配全局置换**

      操作系统维护一个**空闲物理块队列**，进程缺页时可分配。

      空闲物理块不足时，只能窃取其他进程**未锁定**的物理块

    - **可变分配局部置换**

      若进程频繁缺页，操作系统可以为该进程分配更多物理块，直至**缺页率**适当；

      若进程几乎不缺页，操作系统可以剥夺该进程的物理块

  - 调入页面的时机

    - 预调页：根据局部性原理，在进程首次调入时预测其他可能访问到的页面

      > 目前的技术预测成功率只有50%左右

      > **运行前**调入

    - 请求调页：进程运行期间缺页时才调入，或操作系统检查到进程缺页率较高时调入

      > **运行时**调入

  - 调入页面的地点

    - 系统有足够对换区：

      提前将数据从文件区复制到对换区，内存与对换区之间调入调出页面

      > 保证调入调出速度快

    - 系统对换区不充足：

      不会被修改的数据直接从文件区调入内存，可能会修改的数据从对换区调入调出

    - UNIX方式：

      未使用过的页面都从文件区调入，使用过后从对换区调入调出

  - 抖动现象与工作集：

    - 抖动现象描述：刚换出内存的页面马上又要换入，或刚换入内存的页面马上又要换出

    - 抖动现象产生原因：驻留集小于工作集

    - 工作集：在某段时间内，进程实际访问过的**页面集合**

      > 可以通过“窗口尺寸”来确定一段时间，即从页面访问序列的当前位置向前看“窗口尺寸”个页面。这符合局部性原理，也可以据此设计一种页面置换算法

    - 抖动现象解决方案：保证驻留集大于工作集，即增大驻留集或减小工作集

## 4 文件管理

### 4.1 文件与目录概述

*文件概述：*

-   <u>文件的概念</u>：文件就是一组**有意义的信息/数据**集合
-   <u>文件的属性</u>：
    -   文件名：用户创建文件时决定的文件名，主要为了**方便用户找到文件**。**同一目录下不允许有重名文件**
    -   标识符：**操作系统**用于区分各个文件的内部名称。一个系统内各文件标识符唯一
    -   类型：指明文件的**类型**
    -   位置：文件存放的**路径**（让**用户**使用）；文件在**外存中的地址**（**操作系统**使用，对用户不可见）
    -   大小：指明文件的**大小**
    -   时间相关：创建时间、上次修改时间
    -   保护控制相关：文件所有者信息、保护信息（对文件进行保护的访问控制信息）
-   <u>文件的组织</u>：
    -   **无结构**文件：由一些**二进制或字符流**组成，又称”**流式**文件“
    -   **有结构**文件：由一组**相似的记录**组成，又称”**记录式**文件“
        -   **数据项**是文件系统中最基本的数据单位
        -   **记录**是一组相关数据项的集合，**各记录间的组织问题**就是**文件的逻辑结构**问题

    -   **文件之间的组织问题**就是**文件目录**要探讨的问题


---

*操作系统的文件管理概述：*

- <u>操作系统向上提供的**API**</u>：

  -   创建文件：`create`系统调用，在**外存**中创建文件
  -   读文件：`read`系统调用，将文件数据从**外存**读入**内存**，由**CPU**处理
  -   写文件：`write`系统调用，将文件数据从**内存**写回**外存**
  -   删除文件：`delete`系统调用，将文件数据从**外存**中删除
  -   打开文件：`open`系统调用，**读/写文件之前**需要做的操作
  -   关闭文件：`close`系统调用，**读/写文件之后**需要做的操作

- <u>操作系统向下对**磁盘的管理**</u>：

  - 磁盘块的存储与管理

    - 操作以”**块**“为单位为**文件**分配存储空间，以”**块**“为单位划分**外存**

      > ”**块**“的大小通常与内存页大小相同，通常为4KB

    - 文件也具有**逻辑地址**，包括$<逻辑块号,块内地址>$，访问外存时需要转换为**物理地址**，即$<物理块号,块内地址>$

    - 文件在磁盘块上的存储问题就是**文件的物理结构**问题

- 文件共享与保护

    - 文件共享：使多个用户可以**共享使用一个文件**
    - 文件保护：如何保证不同的用户对文件有不同的**操作权限**

---

*文件目录：*

-   <u>文件目录的概念</u>：

    -   文件目录就是**文件控制块**的有序集合，其本身也是一种有结构文件
    -   文件控制块（FCB）：FCB就是文件目录项，一个文件对应一个FCB，记录了各种文件信息
        -   基本信息：**文件名**、**物理地址**、结构、类型、...
        -   存储控制信息：是否可读写、用户访问权限
        -   使用信息：建立时间、修改时间
    -   目录的操作
        -   **搜索目录**：搜索目录中的文件，即目录项FCB
        -   **增加目录项**：创建新文件时需要在所属目录创建目录项
        -   **删除目录项**：删除新文件时需要在所属目录删除目录项
        -   **显示目录**：显示目录内容，例如其中所有文件的属性
        -   **修改目录**：文件属性变化时需要修改相应目录项

-   <u>目录结构</u>：

    -   **单级**目录结构

        -   特点：整个系统只有一级目录表；实现**按名存取**；不允许任何文件重名
        -   缺点：不适用于多用户操作系统

    -   **两级**目录结构

        -   特点：分为**主文件**目录（MFD，Master File Directory）和**用户文件**目录（UFD，User File Directory）；主文件目录记录**用户名**及用户文件目录**存储位置**；用户文件目录记录该用户的文件FCB；允许不同用户的文件重名
        -   优点：在目录上实现**用户访问限制**
        -   缺点：缺乏灵活性，用户不能对自己的文件**分类**

    -   **多级/树形**目录结构

        -   特点：

            用**斜杠分隔的文件路径**标识文件，各级目录用斜杠隔开；

            **绝对路径**查找文件：从外存读入**根目录表**和其他涉及的**目录表**，需要多次磁盘I/O操作；

            **相对路径**查找文件：可以设置一个“**当前目录**”作为查找文件的起点，减少磁盘I/O操作

            >   为什么能减少？因为用户很可能**连续访问同一目录**的多个文件，此时**不必再次调入上级目录**就能直接访问

        -   优点：层次结构清晰，可以对文件灵活分类管理

        -   缺点：不方便文件共享

    -   **无环图**目录结构

        -   特点：在**树形**目录结构的基础上，可以让**不同文件名指向同一个文件结点**（有向无环图）；为每个文件结点设置**共享计数器**，减为0时才删除结点
        -   优点：方便地实现多用户间的文件共享

-   <u>索引结点</u>：

    -   每个文件对应一个**索引结点**，存放除**文件名**之外的描述信息（包括文件在外存中的**存放位置**）
    -   **目录项**只包含文件名、索引结点指针；目录项长度减少，占用的磁盘块减少，检索文件时磁盘I/O次数减少
    -   **硬盘**索引结点与**内存**索引结点
        -   硬盘索引结点：存放在**外存**中的索引结点，在通过**目录项**索引到时才**调入内存**
        -   内存索引结点：调入内存的索引结点，相比于硬盘索引结点，需要增加

### 4.2 文件的结构

*文件的逻辑结构：*

-   <u>文件逻辑结构概述</u>

    -   文件逻辑结构的含义：在**用户**看来文件的数据是如何组织的
    -   文件逻辑结构的分类：
        -   无结构文件：由**二进制或字符流**组成，无明显逻辑结构
        -   有结构文件：由**记录**组成，又称“记录式文件”，每条记录由若干**数据项/字段**组成。分为**定长**记录、**可变长**记录
            -   **顺序**文件
            -   **索引**文件
            -   **索引**顺序

-   <u>顺序文件</u>

    -   **逻辑结构**定义：
        -   文件中的**记录**在逻辑上相邻，**顺序排列**
        -   **串**结构：记录之间的顺序与关键字有关
            
            >    通常按照**存入的时间**决定记录的顺序
        -   **顺序**结构：记录之间的顺序与关键字无关
    -   **物理存储**方式：
        -   **链式**存储：**无法实现随机存取**，只能从第一个记录依次查找
        -   **顺序**存储
            -   **可变长**记录的顺序存储：**无法实现随机存取**，只能从第一个记录依次查找
            -   **定长**记录的顺序存储：**可以实现随机存取**；串结构无法根据关键字快速索引；顺序结构可以根据关键字**快速索引**
    -   特点：
        -   “顺序文件”一般指**物理上也顺序存储**的顺序文件
        -   缺点：增删记录较麻烦
            
            >    如果是串结构不保证顺序，则增加会相对简单

-   <u>索引文件</u>

    -   **逻辑结构**定义：
        -   文件记录通过**索引表**组织起来，每个记录对应一个表项
        -   索引表：一种**定长记录的顺序文件**，可以随机存取，按关键字排序还可以**快速索引**；表项中包括**索引号**（key）、**记录长度**、**记录指针**等信息，可以根据索引号快速查询表项
    -   **物理存储**方式：
        -   文件记录可以在物理上**离散**存放，由索引表项的**指针**指向
    -   特点：
        -   主要用于对**信息处理的及时性**要求比较高的场合
        -   可以用不同数据项为索引号（key）建立**多张索引表**
        -   方便**增删**，实现定长和可变长记录的**随机存取**
        -   缺点：索引表可能占用较大空间

-   <u>索引顺序文件</u>

    -   **逻辑**结构定义：
        -   文件记录**分组**后通过**索引表**组织起来，每个记录对应一个表项组
        -   索引表不必按关键字排序，顺序插入即可
    -   **物理**存储方式：
        -   每组文件记录可以在物理上**离散**存放，由索引表项的**指针**指向
        -   每组内文件记录**顺序**存放
    -   特点：
        -   检索时先**顺序查索引表**找到分组，再**顺序查找分组**内记录
        -   记录过多时可以建立多级索引表

---

*文件的物理结构：*

-   文件物理结构概述
    -   文件物理结构的含义：在**操作系统**看来文件的数据是如何存放在**外存**的，是操作系统对**非空闲磁盘块**的管理方式，也是**文件分配方式**
    -   文件物理结构的分类
        -   连续分配
        -   链接分配
            -   隐式链接
            -   显式链接
        -   索引分配

-   文件块与磁盘块
    -   磁盘块：**磁盘**中的所有存储单元以“块”为单位，称之为磁盘块
        -   磁盘块的大小与**页面**的大小相同
        -   内存与磁盘间的**数据交换**也是以“块”为单位
    -   文件块：文件的**逻辑地址空间**以“块”为单位，称之为文件块
        -   文件的逻辑地址可以表示为：`(逻辑块号, 块内地址)`
        -   操作系统**以块为单位**为文件**分配**存储空间，负责实现文件逻辑地址到物理地址的映射
            
            >    “映射”本质是**逻辑块号**到**物理块号**的映射
    
-   连续分配
    -   存储方式：每个文件在磁盘上占有**一组连续的块**
    -   访问方式
        -   目录项：记录**起始块号**与**文件长度**
        -   通过`物理块号=起始块号+逻辑块号`计算，支持顺序访问与随机访问
            
            >    当然还需要检查逻辑块号是否合法：`逻辑块号<长度`
    -   优缺点
        -   优点：**顺序存取**速度最快；支持**随机访问**
        -   缺点：产生**碎片**，外存利用率低；不利于文件**拓展**
    
-   链接分配-隐式链接
    -   存储方式：离散分配，每个磁盘块都有指向下一个磁盘块的指针
        
        >   这些**指针对用户透明**
    -   访问方式
        -   目录项：记录**起始**块号与**结束**块号
        -   从**起始块号**开始，将磁盘块**读入内存**，进而通过指针找到下一块并读入内存，直到结束
            
            >   读入i号逻辑块需要i+1次磁盘I/O（从0号块开始）
    -   优缺点
        -   优点：不产生碎片，外存利用率高；方便文件拓展
        -   缺点：只支持**顺序访问，**不能随机访问
    
-   链接分配-显式链接
    -   存储方式：离散分配，通过文件分配表(FAT)记录各**磁盘块**指向下一块的**指针/块号**
        -   一个**磁盘**仅设置一张**FAT**，开机时FAT读入**内存**并**常驻**
        -   FAT表项：物理块号+下一块指针/块号
            
            >   FAT各表项物理上连续存储且表项长度相等，所以物理块号其实可以隐含
    -   访问方式：
        -   目录项：记录**起始块号**
        -   从**起始块号**开始，查**FAT**得到下一磁盘块指针/块号，直到找到需要的块号或下一块号为-1
    -   优缺点：
        -   优点：支持顺序访问，也支持**随机访问**，相比于隐式连接访问速度更块；不会产生碎片；方便拓展
            
            >   注意，随机访问指的是**访问第i块不需要依次访问前i-1块**，只需要查询**内存**中的FAT即可
        -   缺点：FAT需要占用一定空间
    
-   索引分配 

    -   存储方式：为每个文件建立**索引表**

        -   **索引表**记录文件各**逻辑块**对应的**物理块**

            -   索引表存放的磁盘块称为**索引块**

            -   文件数据存放的磁盘块称为**数据块**

                >   若文件过大，可以采用链接方案、多层索引、混合索引；
                >
                >   链接方案就是一级索引，索引表长度超过一个磁盘块大小则不得不链接存储
                >
                >   多层索引、混合索引的索引表长度不会超过一个磁盘块

        -   多层索引：多级索引表

            >   会涉及到文件最大长度计算、访存次数计算的问题

        -   混合索引：顶级索引表中部分表项是**直接地址索引**，部分表项是**一级间接**索引、**二级间接**索引等

            >   会涉及到文件最大长度计算、访存次数计算的问题

    -   访问方式：

        -   链接方案的目录项：记录**(顶级)索引块块号**
        -   通过FCB找到各级索引表**读入内存**，查索引表得出逻辑块在外存中的磁盘块号

    -   优缺点：

        -   优点：支持随机访问，方便拓展；混合索引可以兼容大文件与小文件
        -   缺点：索引表需要占用存储空间；对于大文件，链接方案可能需要多次读取索引块；对于小文件，多层索引依然需要读入各级索引表

### 4.3 文件的操作



### 4.4 磁盘的结构与管理
