---
title: golang
category: 学习资源
tags:
  - 计算机
  - go
abbrlink: af1c25a3
date: 2022-09-28 09:45:40
---

## 1 快速入门

### 1.1 安装

下载地址：

- go官网：https://golang.org/dl/
- go官方镜像：https://golang.google.cn/dl/

终端命令：

- go verion

- 查看go环境：go env

  > Go1.11版本之后无需手动配置环境变量

go语言项目：

- 使用go mod管理项目，可以在你磁盘的任何位置新建一个项目。

  > 不需要非得把项目放到GOPATH指定目录下，Go1.13以后可以彻底不要GOPATH了

### 1.2 基础代码编写

```go
package main // 定义包

import "fmt" // import 引入fmt包

func main(){ // 与包同名，为入口函数
    fmt.Println("Hello, World!")
} 
```

> - 语句结尾**不需要加分号**
> - 通过换行区分语句，**不同语句不能写在同一行**
> - 格式化代码：go文件会在保存后自动格式化

*`fmt`包的常用方法*：

- `fmt.Println("xxx", "yyy", ...)`：输出若干个字符串，**中间用一个空格连接**，并在最后**换行**
- `fmt.Print("xxx", "yyy", ...)`：**连接**并输出若干个字符串
- `fmt.Printf("format string", format, ...)`：格式化输出
  - `%v`：自动推导类型后的**数据**
  - `%d`：整型**数据**
  - `%T`：输出**数据类型**

*声明和定义变量*：

> 在go语言中<u>变量</u>**定义后必须使用**，不然报错；

- :star:`var 变量名 [类型] = 表达式`

  - `类型`可以省略，自动推导；但声明时如果不赋值，则**必须指定类型**

  - 一行声明或定义多个变量：

    - 可以一行**声明或定义**<u>同类型</u>的多个变量：`var id1, id2 type = exp1, exp2`

      > 如果声明后不初始化，值为空
      >
      > > 打印出来什么都不显示

    - 一行**定义**类型可以不一致的多个变量：`var id1, id2 = exp1, exp2`

  - 批量**声明或定义**<u>类型可以不一致</u>的变量

    ```go
    var (
        变量名 [类型] = 表达式
        变量名 类型
        id1, id2 [类型] = exp1, exp1
        id1, id2 类型
    )
    ```

    > `类型`可以省略，自动推导，但声明时如果不赋值，则**必须指定类型**

- :star:`变量名1, 变量名2, 变量名3 := 表达式1, 表达式2, 表达式3`

  > 这叫作“短变量声明法”；
  >
  > 类型自动推导，且多个变量同时定义时<u>类型可以不一致</u>
  >
  > 短变量只能用于定义**局部变量**，不能用于全局变量的定义；
  >
  > > 这是因为，函数外的每个语句都必须以关键字开始（var、const、func 等）

  > **<u>匿名变量</u>**：多重赋值时忽略某个值，占位
  >
  > `_, xxx = foo(...)`
  >
  > > 匿名变量不占用**命名空间**，不会**分配内存**，所以匿名变量之间不存在重复声明

*定义常量*：

> 和`var`的用法基本一致，不再赘述相同的部分（当然常量中没有“短变量声明法”）

- `const 变量名 [类型] = 表达式`

  > 常量必须在声明的同时**赋值**

- 一行定义多个常量（与变量用法一致）

- 批量定义常量：

  ```go
  const (
  	常量名 [类型] = 表达式
      常量名 [类型]
      常量名1, 常量名2 = exp1, exp2
      常量名1, 常量名2 [类型]
  )
  ```

  > const 同时声明多个常量时，如果**省略**了值则表示和**上面一行中同一列的值**相同，所以这样也必须保证**<u>列对齐</u>**（变量就不能这样省略）

  > 常量计数器`iota`：在批量定义常量时自动累加
  >
  > - 每次`const`出现时，都会让iota初始化为0，然后自增长
  > - `iota`的值可以跳过
  > - 也可以在同一行中使用`iota`
  >
  > ```go
  > const a = iota // a=0
  > const (
  >     b = iota //b=0
  >     c //c=1
  >     d //2
  >     e = iota //3
  >     f = 100
  >     g = iota //5
  >     h, i = iota, iota //6, 6
  > )
  > ```

*注释*：

- 单行注释：`//`
- 多行注释：`/* */`

## 2 基础语法

### 2.1 基本数据类型

*整型*：

- 有符号整型：

  `int8 int16 int32 int64`

- 无符号整型：

  `uint8 uint16 uint32 uint64`

  > 赋值时不能是**负数**

- 特殊规定的整型：

  - `int`：32 位操作系统上就是`int32`，64 位操作系统上就是`int64`。这也是根据字面量**自动推导**出来的类型
  - `uint`：32 位操作系统上就是`uint32`，64 位操作系统上就是`uint64`
  - `uintptr`：无符号整型，用于存放一个**指针**

  > 实际项目中整数类型、切片、`map`的元素数量等都可以用int 来表示。在涉及到二进制传输、为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用`int`和`uint`

  > `unsafe.Sizeof(var)`是`unsafe`包的一个函数，可以返回变量占用的**字节数**

- 不同长度类型的转换：`int8(numVar) int32(numVar) int(numVar)`

  - 长度向更短转换时会**截断取低位**

- 数字字面量

  - 二进制：`0b11010`，`%b`
  - 八进制：`0o521`,`%o`
  - 十进制：`996`，`%d`
  - 十六进制：`0xc9`，`%x`

  > `%v`是自动推导的输出

*浮点型*：

> IEEE754

- `float32 float64`
- `float`：32 位操作系统上就是`float32`，64 位操作系统上就是`float64`。这也是根据字面量**自动推导**出来的类型
- 格式化输出
  - `%v`
  - `%f`：默认保留6位小数。`%.2f`为保留两位小数
- 科学计数法：`3.14e2`、`3.14E3`、`3.14e-4`、`0.0314E-5`
- 精度丢失问题
  - 可以使用第三方包解决：https://github.com/shopspring/decimal
- 类型转换
  - `float64(numVar) float32(numVar)`
  - `float`和`int`也可以互相转换，截取至整数位，其他同理

*布尔型*：

- `bool`，只有`true`和`false`两个值
  - 布尔类型变量的默认值为`false`
  - 布尔型无法参与**数值运算**，也无法与其他**类型**进行转换

*字符串*：

- `string`，`“xxx”`

  - Go语言中的字符串以**原生数据类型**出现
  - Go语言里的字符串的内部实现使用**UTF-8编码**

- 转义符

  | 转义符 | 换行符 |
  | ------ | ------ |
  | `\r`   | 回车   |
  | `\n`   | 换行符 |
  | `\t`   | 制表符 |
  | `\'`   | 单引号 |
  | `\"`   | 双引号 |
  | `\\`   | 反斜杠 |

- 多行字符串：使用反引号``

  - 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会**原样输出**。

- 常用操作

  - `len(str)`

    > 注意一个汉字占用三个字节

  - 拼接字符串：

    - `+`：两边的数据类型都必须是**字符串**
    - `fmt.Sprint("xxx", yyy, ...)`系列，会直接返回结果，而不是输出到控制台，所以可以用来拼接字符串

  - **分割**字符串：`strings.Split(s, sep string)`，根据`sep`将`s`拆分成切片

    > 需要引入`strings`包

  - **合并**字符串：`strings.Join(elems []string, sep string)`，用`sep`将`elems`切片合并成字符串

  - 子串

    - 子串出现的位置：

      `strings.Index(s, substr string)`

      `strings.LastIndex(s, substr string)`

    - 是否包含子串：`strings.contains(s, substr string)`

    - 是否有**前后缀**：

      `strings.HasPrefix(s, prefix string)`

      `strings.HasSuffix(s, suffix string)`







### 2.2 运算符



### 2.3 流程控制



## 3 数组与切片



## 4 









