---
title: 编译原理
abbrlink: 7a2b5672
date: 2022-09-20 16:27:49
tags: 
  - 计算机
  - 编译原理
category: 学习资源
cover: /bgs/bg7.jpeg
---

## 1 绪论

### 1.1 什么是编译

- 编译就是将高级语言(**源语言**)翻译成汇编语言或机器语言(**目标语言**)的过程
- 预处理器
- 编译器
- 汇编器
- 链接器/加载器



### 1.2 编译系统的结构

1. 分析
   1. 词法分析
   2. 语法分析
   3. 语义分析
2. 综合
   1. 中间代码生成
   2. 代码优化
   3. 目标代码生成
3. 辅助
   - 符号表管理
   - 出错处理



### 1.3 词法分析概述

从**源程序**中：识别**单词**，确定类型，生成***token***，同时在符号表中登记标识符



### 1.4 语法分析概述

从***token*序列**中：识别**短语**，构造**语法分析树**



### 1.5 语义分析概述

根据**语法分析树**

- 收集**标识符**属性信息，形成**符号表**
- **语义检查**
- 子程序和变量的**静态绑定**



### 1.6 中间代码生成及编译

-   生成与机器无关、易于优化与转化的中间表示形式（常用**三地址码**）
-   三地址码：TODO



### 1.7 优化与生成目标机器语言

- 通过**等价**程序变换进行**优化**，提高时空效率
- 生成**目标机器语言**



### 1.8 表格管理

 管理各种**符号表**，辅助语法检查、语义检查，完成静态绑定，为编译的各个阶段提供信息



### 1.9 错误管理

进行各种错误的检查、报告、纠正，以及相应的**续编译处理**



### 1.10 编译程序的组织与生成

编译程序设计的**目标**：

- 程序本身：规模小、速度快、诊断能力强、可移植性好，可扩充性好
- 目标程序：规模小、速度快

前端与后端：

- 前端：与源语言有关、与目标机无关

  > 词法分析、语法分析、语义分析与中间代码生成、与机器无关的代码优化

- 后端：与目标机有关的部分

  > 与机器有关的代码优化、目标代码生成

T形图：

- 描述了**源语言**经编译程序到**目标语言**的过程
- **编译程序的实现语言**可以是高级语言、汇编语言、机器语言，但终究只有**用机器语言实现**才能运行该程序
- T形图可以直观描述语言移植、新语言编译等问题



## 2 程序设计语言及其文法

### 2.1 字母表和串

- **字母表**及其乘积、幂、闭包等运算
- **串**及其连接、幂等运算



### 2.2 文法的定义

文法是一个具有**推导**和**归约**功能的**四元组**：

- **终结符集**（$V_T$）
- **非终结符集**（$V_N$）
- **产生式集**（$P$）
- **开始符号**（$S$）



### 2.3  语言的定义

由文法**开始符号**推导出的所有**句子**构成的集合称为**文法生成的语言**。

文法解决了**无穷语言的有穷表示**问题。

语言有并、连接、幂、闭包等运算。



### 2.4 文法的分类

> 从上至下，要求依次累加

- 无限制文法/短语结构文法

  - 产生式**左部**至少包含一个**非终结符**

- 上下文有关文法

  - 产生式**左部长度小于右部**

- 上下文无关文法

  - 产生式**左部仅为非终结符**

  > <u>左部仅有一个非终结符，右部长度大于左部</u>

- 正则文法

  - 仅允许**左线性**或**右线性**



### 2.5 CFG的分析树

- 分析树是**推导**的图形化表示：

  - 根节点：文法**开始符号**
  - 内部结点：**产生式**
    - **左部**：该节点
    - **右部**：子结点从左到右
  - 叶结点：非终结符或终结符
  - **树的产出/边缘**：从左到右排列叶节点

- （句型的）短语：分析树中每一棵**子树的边缘**

  > 直接短语（简单短语）：高度为2的子树的边缘

- 二义性文法与消歧规则



## 3 词法分析

### 3.1 正则表达式

- 正则表达式是描述**正则语言**的**更紧凑**的表示方法
- 它可以**递归构建**
- 与**正则文法**等价
- 有自己的**代数定律**



### 3.2 有穷自动机

> 核心就是：`状态 + 输入 + 转换`

- 有穷自动机（FA）：

  - 一种处理系统的数学模型。这种处理系统由**输入带、读头、有穷控制器**构造，可以根据当前**状态**和**输入**转入下一状态。
  - FA有其定义/接收的**语言**
  - FA遵循最长子串匹配

- DFA：一种代表FA模型的**五元组**

  - **有穷状态集**（$S$）

  - **输入字母表**（$\Sigma$）

    > $\epsilon\notin\Sigma$

  - **转换函数**（$\sigma$）：$S\times\Sigma\rarr S$

  - **开始状态**（$s_0$）

  - **接收状态**（$F$）

- NFA：一种代表FA模型的**五元组**

  - **有穷状态集**（$S$）

  - **输入字母表**（$\Sigma$）

  - **转换函数**（$\sigma$）：$S\times\Sigma\rarr 2^S$

    > $\epsilon-NFA$与$NFA$的区别就在于转换函数：$S\times(\Sigma\cup\{\epsilon\})\rarr 2^S$

  - **开始状态**（$s_0$）

  - **接收状态集合**（$F$）




### 3.3 RE与FA的转换

- RE$\rarr$NFA：**分解、递归**
  - RE与NFA的对应规则
- NFA$\rarr$DFA：**状态转换表**
  - 子集构造法



### 3.4 词法单元token

- 词法单元token是源程序中**单词的机内表示**，由**种别码和属性值**构成
- 种别码：记录单词**类型**
  - 一词一码：关键字、运算符、界限符
  - 一型一码：常量、运算符
  - 多词一码：标识符

- 属性值：记录单词**字面值**
  - 一词一码：不需要属性值
  - 一型一码：用属性值区分同一类型的单词
  - 多词一码：用属性值记录无法枚举的标识符字面值




### 3.5 词法分析阶段的错误处理

- 错误类型
  - **单词拼写**错误
  - **非法字符**
- **错误处理程序**
  - 调用时机：**当前状态与当前输入信息为空**
  - 处理方式：查找已扫描字符串的最后一个**终态字符**
    - 找到了：识别成一个**单词**，回到初态
    - 没找到：错误恢复策略（**恐慌模式**）



## 4 语法分析

### 4.1 自顶向下分析概述

- **<u>自顶向下</u>构造语法分析树**，每次用**最左非终结符**（树的最左非终结符节点、最左推导），根据**输入符**，选择其合适的**产生式**，进行替换（生成子节点）
- 一般的自顶向下分析往往会因为**产生式选择的不确定性**而需要**回溯**，但**<u>预测分析</u>**就不需要回溯，它依据**预测分析表**，是一种**确定的自顶向下分析方法**
- 并不是所有文法都直接适用于自顶向下的分析，文法转换就是要**改造这些文法**以使其适合**自顶向下的分析**。
  - 常见的文法转换就是**消除左递归**，因为左递归会导致**无限递归**。
  - **提取左公因子**也是一种文法转换方式，本质是在**推迟决定**，从而**减少回溯**。
  - 当然，还要消除**文法的二义性**



### 4.2 预测分析法

- 构造与检查文法
  - 构造一般文法
  - 改造文法：消除二义性、消除左递归、消除回溯
  - 检查是否为LL(1)文法
- 设计算法
  - 递归的预测分析：”递归“程序
  - 非递归的预测分析：下推自动机



#### 4.2.1 适合预测分析的文法

> 目标：构造不需要回溯、可用于预测分析的文法（前提是要先适用于自顶向下分析）。
>
> 注：可以将下述文法看成**上下文无关文法**的改进，在此基础上加入或减少约束。

- S_文法

  - 产生式**右部**以**终结符**开始（不包含$\epsilon$产生式）
  - 同一非终结符各个候选式的**首终结符**都不相同

- q_文法

  - 产生式**右部**或为$\epsilon$，或以**终结符**开始

  - 具有相同左部的产生式有**不相交的可选集**

    - <u>***可选集***</u>：可以使用该产生式推导时的**输入符号**集合，称为这个产生式的可选集

      > 如果是条空产生式，则可选集等于其左部非终结符的**后继符号集**。
      >
      > > <u>***非终结符的后继符号集***</u>：可能在某个句型中**<u>紧跟</u>在该非终结符后的终结符**
      >
      > > 具体计算方法在下文中有介绍

- LL(1)文法：<u>同一非终结符各个**产生式**的**可选集**互不相交</u>

  > 下面这三条限制其实就是为了保证“同一非终结符各个产生式的可选集互不相交”

  - 同一非终结符各个**候选式**的**串首终结符集**不相交

    > <u>***串首终结符集***</u>：可以从文法符号(串)推导出的所有符号串的**串首终结符**，称为这个文法符号(串)的串首终结符集
    >
    > > 串首终结符：串首第一个符号，并且是终结符。简称首终结符

  - 同一非终结符各个**候选式**至多有一个能**推导出$\epsilon$**

  - 同一非终结符若存在一个候选式能推导出$\epsilon$，则该非终结符的**后继符号集**和其他候选式的**串首符号集**互不相交

- 非终结符FIRST集的计算

  1. 处理所有**空产生式**和**右部以终结符开头**的产生式：直接把$\epsilon$或**右部开头的终结符**加入左部非终结符的FIRST集
  2. 处理**右部以非终结符开头**的产生式
     - 加右部”开头“的first：看**整条产生式**，<u>**右部开头**的非终结符</u>，以及可能因左方非终结符推导出$\epsilon$而**变成右部开头**的非终结符，其FIRST集要**包含于**左部非终结符的FIRST集

  > 上面说的是非终结符的FIRST集，
  >
  > - 如果要求**终结符的FIRST集**，就是只包含该终结符一个元素的集合
  >
  > - 如果要求**文法符号串的FIRST集**，从左向右看，加入第一个**符号的FIRST集**，若该符号能推导出$\epsilon$就累加继续下一个**符号的FIRST集**，直到不能再推出$\epsilon$，如果都能推导出$\epsilon$就再加入$\epsilon$

- 非终结符的FOLLOW集的计算

  1. 将**结束标记**加入<u>开始符号的FOLLOW集</u>中
  2. 不断遍历所有产生式，直到无法再添加新的终结符到某一FOLLOW集中，添加规则为：
     - 加右边的first：单看**产生式右部**，跟在<u>某一非终结符</u>**后面的符号串的FIRST集**加入该非终结符的FOLLOW集中（除了$\epsilon$）
     - 加左部的follow：看**整条产生式**，<u>**右部结尾**的非终结符</u>，以及可能因右方非终结符推导出$\epsilon$而**变成右部结尾**的非终结符，其FOLLOW集要**包含**左部非终结符的FOLLOW集

- 产生式的SELECT集的计算

  - 若是空产生式，则为**左部**非终结符的**FOLLOW集**
  - 若非空产生式，则为**右部**符号串的**FIRST集**

- 预测分析表

  - 行是非终结符，列是输入符号
  - 表项是产生式，其左部行代表的非终结符，且列代表的输入符号属于其SELECT集





#### 4.2.2 预测分析算法

> 使用以下算法的必要条件是，文法适用于预测分析

- 递归的预测分析法

  - 从文法**开始符号的产生式**开始，遍历右部符号（即**调用文法开始符号的过程**）

    > 遍历符号的过程中，每次取得一个输入，终结符消耗输入，非终结符根据输入选择产生式

    - 若为终结符，则必须等于当前输入符号，否则报错

    - 若为非终结符，则“递归”调用**该非终结符对应的过程**

      > 非终结符对应的过程：
      >
      > - 若有**多条产生式**，先根据输入和SELECT集选择产生式
      > - 遍历产生式右部符号，若是终结符，则当前输入必须与之相等，否则报错；若是非终结符，则调用其过程

  - 最后一个输入符号必须是终结符

- 非递归的预测分析法：借助**下推自动机**，初始时，栈顶为开始符，栈底为结束符

  - 对比输入符号与栈顶符号，直到栈顶和输入都为结束符
  - 若栈顶符号为**终结符**
    - 二者**相等**，则弹栈，消耗输入符号，读头后移
    - 二者不相等，则报错
  - 若栈顶符号为**非终结符**：根据SELECT集选择**产生式**，根据产生式，左部弹栈，右部入栈，入栈顺序与右部书写顺序相反，不消耗**输入符号**

  > 非递归的，也叫**表驱动的预测分析法**
  >



#### 4.2.3 预测分析法的错误处理

- 错误检测
  - 最左/栈顶**终结符**与当前输入符号不匹配
  - 最左/栈顶**非终结符**与当前输入符号在**预测分析表**中无可用产生式
- 错误恢复：恐慌模式
  - 最左/栈顶**终结符**与当前输入不匹配时：直接忽略输入符号
  - 最左/栈顶**非终结符**与当前输入符号在**预测分析表**中无可用产生式：
    - 若输入符号在该非终结符的FOLLOW集中（同步词法单元），则忽略/弹出该非终结符
    - 若输入符号不在该非终结符的FOLLOW集中，则忽略输入符号



### 4.3 自底向上分析概述

- 自底向上分析也叫**移入-归约分析**

  > 借助**栈**来理解

  - 移入：将**输入符号**压入栈

  - 归约：从栈中依次**弹出**能构成**产生式右部**的若干个符号，然后将**左部压入栈**（最左归约）

    > 最左归约称为规范归约、最右推导称为规范推导

  - 移入-归约分析中的关键问题是**正确识别最左直接短语（句柄）**

    > **<u>句柄：当前句型的最左直接短语</u>**

- **LR分析**是移入-归约分析的重要方法

  > 从**左**到右扫描，反向构造最**右**推导

  - 用**状态**表示**句柄识别的进展程度**，<u>状态栈与符号栈平行</u>（栈中**元素个数保持相等**）

    > 状态的可视化表示就是在产生式右部插入一个圆点，代表**离可以使用该产生式归约**还差什么符号，**圆点右边的符号**就是需要的符号

    - 移进状态：圆点后面是终结符
    - 待约状态：圆点后面是非终结符
    - 归约状态：圆点后面没有符号

  - 只要构造出正确的**<u>分析表</u>**就可以直观且快速地识别了，分析表的概述如下：

    - **一行**对应一个**状态**，一个状态的**一条边**对应于该行的**一个表项**
    - **一列**对应一个**文法符号**，终结符和结束符在**ACTION列组**，非终结符在**GOTO列组**
    - 表项中，$s_n$代表将**所在列对应符号和状态n**同时压入栈符号栈和状态栈；$r_n$代表使用第n个产生式归约，同时弹出**产生式右部**符号(串)和与其**平行的状态**，并压入阻塞的常规信号不支持排队，产生多次只记录一次，再根据**当前栈顶状态**和**该非终结符**找到GOTO列组的项k，这代表着再**将状态k压入栈**；acc代表成功识别，err代表出错
    - 从状态栈只有初始状态0、符号栈只有结束符$\$$开始，根据**当前状态(行)和输入符号(列)**找到表项，执行对应的操作，直到读取输入后找到的表项为acc或err


  > 所以，**构造出文法的分析表**是LR分析的关键



### 4.4 LR(0)分析

> :star:LR系列的相关概念较多，暂不探讨定义这些概念的内在原因，只要能将其**<u>应用到问题中</u>**即可

- LR(0)相关<u>概念</u>

  - **增广文法**：新增<u>开始符号</u>，它能推导出原开始符号（$S'\rarr S$）

    > 增广文法让分析器**只有一个接受状态**

  - **项目**：项目描述了**句柄识别的状态**

    - 移进项目

    - 待约项目

        >   开始符号对应的待约项目称为<u>初始项目</u>（$S'\rarr\cdot S$）

    - 归约项目

      > 开始符号对应的归约项目称为<u>接收项目</u>（$S'\rarr S\cdot$）

  - **后继项目**：同属一个产生式但圆点只差一个符号，圆点在后的是后继项目

  - **等价的项目/项目集闭包**：对于一个**待约**项目，它的等价项目就是，以该待约项目**圆点后面的符号为<u>左部</u>**的所有<u>产生式</u>将**圆点放在<u>右部</u>第一个符号前**得到的项目；被等价推出的**待约**项目可以继续等价推出，直到不能再推出新的待约项目。这样推出的所有项目都放在一个集合中，这个集合就是**项目集闭包**。

    > 对于移进项目和归约项目，它们可以被待约项目等价推出，但不能等价推出别的项目。如果它们不能由某个待约项目等价推出，则它们没有等价项目

  - 项目集对应于**文法符号X(包括终结符和非终结符)**的**后继项目集闭包**（`GOTO(I, X)`函数）：项目集中**圆点<u>右紧邻符号为X</u>**的每一个项目的**<u>后继</u>项目集闭包的并**

- LR(0)<u>自动机与分析表</u>

  - 自动机的构造

    1. 初始项目（$S'\rarr\cdot S$）的**项目集闭包**构成**状态0**
    2. 对于**每一个现有状态**，求其对于**每一个文法符号(包括终结符和非终结符)**的后继项目集闭包（`GOTO(I, X)`），若`GOTO(I, X)`不为空，则将其作为一个新的状态（如果是已经存在的状态就不必当成新状态了），并生成一条当前状态指向`GOTO(T, X)`对应状态的**有向边**，边上的符号为当前文法符号
    3. 循环执行2**直到不再增加有向边**

  - 分析表的构造

    - **接收项目**是单独在一个状态里，对应**接收状态**，在表中与结束符$\$$形成表项$acc$

    - 对于一个状态i（一行）

      > 一个状态中若既有**归约项目**又有其他类型的项目，则会出现冲突，这里暂不考虑

      - 出边上是**非终结符**的，对应该行的**GOTO表项**，为有向边指向的状态编号$j$
      - 出边上是**终结符**的，对应该行的**ACTION表项**，为有向边指向的状态$s_j$
      - 若**没有出边**，或者说状态中**只有一个归约项目**，则该行的ACTION表项全为$r_k$（k为该归约项目对应的**产生式编号**）

- LR(0)会有**移进/归约**冲突和**归约/归约**冲突

  - 对应到自动机中，就是一个状态中**同时存在归约项目和其他类型项目**，或者同时存在**多个归约项目**，导致遇到下一个输入时无法判断执行什么动作
  - 对应到分析表中，就是ACTION列组的**一个表项**会有**两个可选值**
  - 出现问题的本质原因是，LR(0)分析没有**向前查看符号**，没考虑**上下文环境**



### 4.5 SLR分析

- SLR分析基本思想

  > S：Simple，仅通过FOLLOW集化解冲突

  - 是对LR(0)分析的改进，**在LR(0)分析的基础上**，不是遇到所有输入符号都能归约的，因为归约后左部符号的**FOLLOW集**中可能没有该输入符，也就是归约后的符号后面不可能紧接这个输入符

  - 当遇到LR(0)中所述冲突时，要考察两种集合(是两种，不是两个。第一种里只有一个，第二种里可以有多个)：

    - 第一种是状态中**所有移进/待约项目**<u>圆点右侧符号构成的集合</u>，
    - 第二种是状态中所有**归约项目**对应<u>产生式左部非终结符的**所有FOLLOW集**</u>。

  - 当这些集合两两不相交时：

    > 若不能做到两两不相交，则说明SLR无法解决这种冲突

    - 若**输入符号**在<u>圆点右侧符号构成的集合</u>中，则执行对应的移进ACTION；
    - 若**输入符号**在<u>某个归约项目左部的FOLLOW集</u>中，则执行对应的归约ACTION。
    - 其他情况报错

- SLR<u>自动机与分析表</u>

  - 自动机的构造：与LR(0)一样的

  - 分析表的构造：在LR(0)构造的分析表基础上，只有**ACTION列的终结符**在对应状态中归约项目左部符号的**FOLLOW集**中时，才进行归约，否则的话，要么是**移进**，要么**表项为空**

    > 若这样做之后一个表项中还是会留下多个动作，则说明SLR无法解决这种冲突

- SLR分析中的冲突

  - 上述的两种集合不能做到**两两不相交**
  - 本质原因是，对于归约项目，输入符号在其左部**FOLLOW集**中，只是能归约一个**必要条件**，并非充分条件



### 4.6 LR(1)分析

- 基本思想与概念

  - 在LR分析的**特定位置**，对于非终结符A，并非FOLLOW(A)中的所有符号都可以接在A后面，所以并不是输入符在FOLLOW(A)中了就可以使用以A为左部的这条产生式进行归约，我们需要找到**非终结符A在特定位置的后继符**

  - 规范LR(1)项目：$A\rarr\alpha\cdot\beta, a$（$第一分量,第二分量$）

    - 第一分量：右部带圆点的产生式（就是之前对于项目的定义）

    - 第二分量：展望符，代表当前状态下A后面可以紧跟的终结符。对于归约项目（$A\rarr\alpha\cdot,a$），代表输入符号为a时才能使用该产生式归约

      > 对于移入项目和待约项目（$A\rarr\alpha\cdot\beta, a且\beta\ne\epsilon$），**展望符与之无关**，但为了定义的完整，把它写出来了

  - <u>**等价**LR(1)项目/**展望符**的计算</u>：

    - 第一分量：就是之前定义过的**等价项目**

    - 第二分量/展望符：要看等价项目产生式的**左部**在原项目中**右边的符号(串)**$\beta$。若$\beta$能推出空（或者$\beta$本身就是空的），则直接继承相同的展望符；否则，对于$FIRST(\beta)$中的<u>每个终结符</u>，都可以作为**展望符**与相同的**第一分量**构成一个等价的项目

      > 从计算展望符的角度讲，就要从初始项目$S'\rarr\cdot S,\$$出发按照自动机的构造方法去计算了

- LR(1)的自动机和分析表

  > 相比于LR(0)，LR(1)对于CLOSURE、GOTO、项集族、自动机、分析表构造算法都做了适合于**展望符与归约项目**的修改

  - 自动机的构造：从初始项目$S'\rarr\cdot S,\$$开始，与LR(0)的生成规则类似，只是在计算项目等价的时候要考虑**展望符**

  - 分析表的构造：

    - 对于不涉及归约项目的状态，处理方法与LR(0)相同

    - 对于涉及归约项目的状态，只有ACTION列(输入符号)是状态中归约项目的**展望符**时才能规约

      > 之前构造SLR的时候，是遇到左部FOLLOW集中的符号都能规约



### 4.7 LALR分析

- LALR基本思想与概念

  - LR(1)的状态过多，其中有些状态是可以合并的
  - **同心项目集**（同心状态）：只保留第一分量时(重复的只留一个)，完全相同的项目集
  - 同心项目集是可以合并成一个状态的，其实是在对**展望符**进行合并

- LALR的自动机与状态表

  - 自动机：在构造出的LR(1)自动机基础上，合并同心项目并修改边
  - 分析表：与LR(1)的构造方法相同

- LALR的问题

  - 归约-归约冲突：同一个输入符，不知道该用状态中的哪个产生式归约了，因为它们的**展望符**都相同

  - 推迟错误发现：合并同心项集后，虽然不产生冲突，但可能会**推迟错误的发现**

    > LALR分析法可能会作多余的**归约动作**，但绝不会作错误的**移进操作**。因为LALR其实是在合并展望符集合，而展望符与归约有关，与移进无关

- LALR的特点

  - 形式上与LR(1)相同，都有**展望符**
  - 大小上与LR(0)/SLR相当，因为**合并了状态**
  - 分析能力上，$SLR<LALR<LR$。相比于SLR，LALR细化了状态；相比于LR(1)，LALR会延迟错误的发现。



## 5 语法制导翻译

> 在编译原理中，产生式往往有着具体到代码层面实际意义，产生式的应用场景决定了其在翻译过程中的实际意义

### 5.1 基本思想

- 语法制导翻译的基本思想是，用**产生式**代表**语法规则**，再为产生式关联需要的**语义规则**，在**构造语法分析树**的同时通过语义规则**计算语义属性值**

- 语法制导定义SDD：

  > 对上下文无关文法的推广

  - 为每个文法符号设置若干**语义属性**
  - 为每条产生式关联若干**语义规则**，语义规则用于**计算语义属性值**

- 语法制导翻译方案SDT：

  - 在SDD的基础上，直接**将语义规则嵌入产生式右部**，称为**语义动作**
  
    > 将**属性值计算**的工作解耦给**语义动作**
  
  - **语义动作**在产生式中的**位置**决定了其**执行时间**
  
  - SDT可以看作是SDD的**具体实施方案**，有SDT就能按照一定的**工作流程**计算所有语义属性值
  
    > SDT通用的实现方法：首先建立一棵**语法分析树**，然后按照**从左到右的深度优先顺序**来执行这些动作



### 5.2 语法制导定义

- 文法符号的属性

  - 综合属性：
    - 非终结符的综合属性只能通过**子结点**或其本身的属性值定义
    - 终结符的综合属性是由词法分析器提供的词法值（**token属性值**）
  - 继承属性：
    - 非终结符的综合属性只能通过**父结点、兄弟结点**或其本身的属性值定义
    - 终结符没有继承属性

- 副作用与属性文法

  - 有的语义规则目的是产生**副作用**，用到了其他结点的属性值，但不计算新的属性值，可以理解成在计算**虚属性**

    > 比如打印、在符号表中创建记录并设置类型等等，后面会陆续接触到

  - 没有副作用的SDD称为**属性文法**，仅通过其他属性值和常量定义属性值

- 属性求值

  - 属性求值遵循的顺序是：**依赖图的拓扑排序**
  - 依赖图是描述分析树**结点属性的依赖关系**的有向图，以语法分析树为基础图，若结点X有属性a，则将a也作为依赖图中的结点（画在X旁边）；若属性X.a的值计算依赖于Y.b，则添加一条Y.b指向X.a的有向边；如果有“虚属性”，也可以画在结点旁边。
  - 一个SDD不一定存在可行的求值顺序，有可能发生**循环依赖**

- 属性定义：SDD的有用子类，一定存在一个求值顺序

  - S-属性定义/S属性的SDD：只具有综合属性的SDD
    - S-SDD可以按照语法分析树自底向上的顺序计算各属性值
    - S-SDD可以**在自底向上的语法分析**中实现
  - L-属性定义/L属性的SDD：每个属性要么是**综合属性**，要么是只依赖 **父结点继承**属性、**左兄弟**结点属性、**本身**属性 的**继承属性**（但本身的属性不能形成**环路**）



### 5.3 语法制导翻译方案

- <u>SDD向SDT的转换</u>

  - S-SDD转换为SDT：
    - 将每个语义动作都放在**产生式右部的最右端**，代表在规约时计算属性值
    - 如果S-SDD的基本文法可以使用LR分析技术，那它的SDT就可以在LR分析过程中实现
  - L-SDD转换为SDT：
    - 计算产生式左部符号**综合属性**的语义动作放在**产生式右部的最右端**
    - 计算产生式右部非终结符**继承属性**的语义动作插入**非终结符紧邻左边**

- <u>S-SDD的自底向上翻译</u>

  - 扩展LR语法分析栈：在分析栈中附加一个域存储**综合属性**（值或指针），与文法符号平行
  - 分析栈的工作：在规约时执行语义动作，找到栈中对应位置的依赖，计算属性值，存入附加域

- <u>L-SDD的非递归预测分析翻译</u>

  - 扩展预测分析栈

    - 继承属性在即将出现时计算，存放在**与非终结符平行的记录`A`**中（横向扩展）
    - 综合属性在子结点分析完后计算，**新增一条<u>综合记录</u>`Asyn`**存放（纵向扩展）
    - 增加一种**<u>动作记录</u>`action`**，指向要执行的动作（纵向扩展）

  - 分析栈的工作

    - 依然按照右部从右向左的顺序入栈，**综合记录`syn`先**于本身记录入栈，动作记录`action`同样按照所处位置入栈

      > 往往会给语义动作对应的动作记录取一个简洁的**别名**

    - 栈内元素的出栈行为：

      栈顶为**动作记录**时，直接出栈并执行对应动作；

      栈顶为**综合记录**时，直接出栈并将**综合属性值传递**给栈内的特定语义动作；

      **变量本身记录**出栈时，若有继承属性，则要将**继承属性值传递**给入栈的特定语义动作；
    
      **终结符**出栈时要将**综合属性值**传递给栈中的特定语义动作
    
      > 这里的“传递”具体到程序上就是`stack[top+-n].xxx=stack[top].xxx, top=top+-n`，其中`top+-n`对应了语义动作出现的位置
    
    - **综合属性**的计算：<u>综合属性</u>在对应产生式右部**最右端语义动作出栈**时计算
    
    - **继承属性**的计算：变量本身记录的<u>继承属性</u>在对应产生式**紧邻左边动作出栈**时计算
    
      > 这里的“计算”具体到程序上，也是给`stk[top+-n]`赋值，涉及到一些计算，其中`top+-n`对应了综合记录或变量本身记录出现的位置

- L-SDD的递归预测分析翻译

  - 在**递归预测分析**基础上，将非终结符的过程扩展为**函数**，参数为**继承属性**，返回值为**综合属性**

    > 递归的预测分析中过程调用的框架在这里要沿用

  - 对产生式右部符号的每个属性都设置**局部变量**

    > 函数返回值由综合属性的局部变量接收

  - 将每个**语义动作**的代码依次加入函数体，使用对应的变量书写其动作逻辑

    - 继承属性的计算：按照语义动作计算并赋值给对应局部变量
    - 综合属性的计算：按照语义动作计算、赋值给对应局部变量并**返回**

- L-SDD的自底向上翻译

  - **修改文法**以适应自底向上

    - 用各个“**标记非终结符**”替换**内嵌**的各个**语义动作**，每个标记非终结符都对应一条空产生式
    - 标记非终结符的空产生式最右端添加新语义动作，将原动作依赖的属性作为**标记非终结符的继承属性**，将原动作要计算的属性作为**标记非终结符的综合属性**来计算

    > 可以证明，如果一个文法是LL的，那么标记非终结符可以插入到产生式的任何位置，并且得到的文法是LR文法

  - 分析栈的工作

    - 与S-SDD基本一致，原继承属性的计算变成了**对标记非终结符综合属性的计算**
    - 计算标记非终结符时，要结合原产生式和继承属性的实际情况确定依赖位置和计算方式



## 6 中间代码生成

> 这一小节十分需要用具体的例子辅助理解，详见编译原理随堂笔记仓库

### 6.1 声明语句的翻译

*主要任务：*

- 通过**类型表达式**，收集**标识符类型**等属性信息
- 由类型表达式计算**宽度**，从而为每个标识符分配一个**相对地址**
- 将标识符类型和相对地址等信息保存至对应**符号表**

---

*类型表达式(Type Expreessions)：*

- **基本类型**是一种类型表达式，常见基本类型有：

  `integer real char boolean type_error void`

- 可以给类型表达式命名，**类型名**也是一种类型表达式

- **类型构造符**作用于类型表达式可以构成新的类型表达式

  - 数组构造符`array(elem_num, type)`

    > 举例：`int[2][3]`对应于`array(2, array(3, int))`

  - 指针构造符`pointer(type)`

  - 笛卡尔乘积构造符$\times$：`T1 × T2`

  - 函数构造符$\rarr$：`T1 × T2 × ... × Tn → R`

    - `Ti`是类型表达式，相当于参数
    - `R`也是类型表达式，相当于返回值

  - 记录构造符`record((N1×T1), (N2×T2), ..., (Nn×Tn))`

    - `Ni`是标识符
    - `Ti`是类型表达式

---

*声明语句的SDT：*

- <u>文法符号与综合属性</u>

  - `P`：开始符号

  - `D`：声明语句

  - `T`：标识符类型

    - `T.type`：类型表达式
    - `T.width`：类型宽度

  - `B`：基本类型

    - `B.type`：基本类型
    - `B.width`：基本类型宽度

  - `C`：数组标志

    - `C.type`：数组类型
    - `C.width`：数组类型宽度

  - `id`：标识符

    - `id.lexeme`：构成标识符的字符序列

      > 是词法分析器提供的词法值

  - `num`：整数的正则定义

    - `num.val`：整数值

  - `int`：整型

  - `real`：实型

  - `↑`：指针标志

- <u>特殊变量</u>

  - `offset`：下一个可用的**相对地址**，有初始值，可设为0

  - `t`和`w`：将**类型和宽度信息**从语法分析树的B结点传递到产生式$C\rarr\epsilon$对应的结点

    > 最终其实是传递到`T`了

- <u>副作用</u>

  - `enter(name, type, offset)`：在符号表中为标识符`name`创建记录，将`name`的类型设置为`type`，相对地址设置为`offset`

- <u>语法规则和语义动作</u>

  - 开始：$P\rarr\{a_1\}D$
    $$
    \begin{align*}
    &a_1:\{\\
    &~~~~offset=0\\
    &\}
    \end{align*}
    $$

    > 声明语句形成前要将`offset`置为初始值

  - **声明语句**的生成：

    - $D\rarr T~id;\{a_1\}D$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~enter(id.lexem,~T.type,~offset);\\
      &~~~~offset=offset+T.width;\\
      &\}
      \end{align*}
      $$

      > 一条完整声明语句形成后要在符号表创建记录，并后移`offset`

    - $D\rarr\epsilon$

  - **标识符类型**的形成：

    - $T\rarr B\{a_1\}C\{a_2\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~t=B.type;\\
      &~~~~w=B.width;\\
      &\}\\
      &a_2:\{\\
      &~~~~T.type=C.type;\\
      &~~~~T.width=C.width;\\
      &\}
      \end{align*}
      $$

      > **基本类型**分析完后要用`t`和`w`记录**类型和宽度**，以便向后传递；
      >
      > 一个**完整标识符类型**形成后要设置类型的**类型表达式和类型宽度**

    - $T\rarr\uarr T_1\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~T.type=pointer(T_1.type);\\
      &~~~~T.width=4;\\
      &\}
      \end{align*}
      $$

      > 形成指针后要设置其**类型和宽度**

  - **基本类型**的形成：

    - $B\rarr int\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B.type=int;\\
      &~~~~B.width=4;\\
      &\}
      \end{align*}
      $$

      > 形成整型后要设置其类型和宽度

    - $B\rarr real\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B.type=real;\\
      &~~~~B.width=8;\\
      &\}
      \end{align*}
      $$

      > 形成实型后要设置其类型和宽度

  - **数组标志**的形成：

    - $C\rarr\epsilon\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~C.type=t;\\
      &~~~~C.width=w;\\
      &\}
      \end{align*}
      $$

      > 数组标志开始形成时要从`t`和`w`中读取信息，以便后续**数组类型和宽度**的计算
      >
      > > 从推导和归约不同的角度讲，这条产生式可能代表数组标志的开始或结束，但**类型和宽度的计算逻辑**是相同的，思维要灵活一点

    - $C\rarr[num]C_1\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~C.type=array(num.val,C_1.type);\\
      &~~~~C.width=num.val*C_1.width;\\
      &\}
      \end{align*}
      $$

      > 形成数组标志时要用**数组构造符**其设置类型并**计算宽度**



### 6.2 简单赋值和运算语句的翻译

*主要任务：*

- 生成**对表达式求值**的三地址码

  > 三地址码中地址不直接参与运算，而是**存放在所指向地址的值参与运算**。
  >
  > 例如下文中经常出现的`E.addr`，如果放到运算表达式中，其实代表的是存放在所指向地址的值

- 正确处理**数组元素**等复杂表达式

  > 对于**数组元素**要计算其**地址索引**：
  >
  > $addr(a[i_1][i_2]...[i_k])=base+i_1\times w_1+i_2\times w_2+...+i_k\times w_k$

---

*简单赋值和运算语句的SDT：*

- <u>文法符号与综合属性</u>

  - `S`**：开始**符号，同时也代表**完整的赋值语句**，或者认为其代表一个**代码块**
    - `S.code`：存放完整**赋值过程**的所有三地址码
  - `E`：表达式
    - `E.code`：存放**表达式之间赋值**的三地址码
    - `E.addr`：表达式**值的存放地址**
  - `id`：标识符
    - `id.lexeme`：构成标识符的字符序列
  - `L`：**数组元素**
    - `L.type`：数组元素的**类型**
    - `L.offset`：数组元素的**地址偏移量**
    - `L.array`：数组**入口地址**，也是数组标识符在符号表中记录的地址
  - `(`
  - `)`

- <u>副作用</u>

  - `lookup(lexeme)`：查询符号表中**标识符**指向的**地址**

    - `lookup(id.lexeme).type.elem`：（如果`id`是数组标识符）数组元素类型

      > `.elem`相当于取更高维度的元素**类型**

    - `lookup(id.lexeme).type.elem.width`：数组元素类型的宽度

  - `newtemp()`：生成临时变量并返回其地址

    > 这里虽然叫做“临时变量”，但这个变量依然会被写进**三地址码**中，只是在逻辑上起**临时记录值**的作用

  - `gen(code)`：生成新的**三地址码**（并拼接已生成的三地址码，赋值给综合属性）

    > :star:增量翻译：在语义动作中简化类似`E.code=E1.code||E2.code||gen(xxx)`的代码，直接写成`gen(xxx)`，这样代表了**生成三地址码**后自动将子结点的`code`属性与之**顺序拼接**并赋值给父节点的`code`属性

- <u>语法规则和语义动作</u>

  - 文法开始/**完整赋值语句**的形成：

    - $S\rarr id=E;\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~p=lookup(id.lexeme);\\
      &~~~~if~p==nil~then~error;\\
      &~~~~gen(p=E.addr);\\
      &\}
      \end{align*}
      $$

      > 形成**单一标识符**赋值语句时生成**给目标标识符赋值**的三地址码

    - $S\rarr L=E;\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~gen(L.array[L.offset]=E.addr);\\
      &\}
      \end{align*}
      $$

      >形成**数组元素**赋值语句时生成**元素地址索引并给其赋值**的三地址码

  - **算术表达式**的形成

    - $E\rarr E_1+E_2\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~E.addr=newtemp();\\
      &~~~~gen(E.addr=E_1.addr+E_2.addr);\\
      &\}
      \end{align*}
      $$

      > 形成加法运算表达式时生成用**临时变量存放运算结果**的三地址码

    - $E\rarr E_1*E_2\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~E.addr=newtemp();\\
      &~~~~gen(E.addr=E_1.addr*E_2.addr);\\
      &\}
      \end{align*}
      $$

      > 形成乘法运算表达式时生成用**临时变量存放运算结果**的三地址码

    - $E\rarr-E_1\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~E.addr=newtemp();\\
      &~~~~gen(E.addr=uminus~E_1.addrr);\\
      &\}
      \end{align*}
      $$

      > 形成取相反数运算表达式时生成用**临时变量存放运算结果**的三地址码

    - $E\rarr(E_1)\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~E.addr=E_1.addr;\\
      &\}
      \end{align*}
      $$

      > 形成括号运算表达式时生成用**临时变量存放运算结果**的三地址码

    - $E\rarr id\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~E.addr=lookup(id.lexeme);\\
      &~~~~if~E.addr==nil~then~error;\\
      &\}
      \end{align*}
      $$

      > 由标识符形成表达式时要**记录标识符地址**

  - **数组元素表达式**的形成

    - $E\rarr L\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~E.addr=newtemp();\\
      &~~~~gen(E.addr=L.array[L.offset]);\\
      &\}
      \end{align*}
      $$

      > 形成**完整数组元素表达式**时生成用**临时变量存放数组元素地址索引**的三地址码

    - $L\rarr id[E]\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~L.array=lookup(id.lexeme);\\
      &~~~~if~L.array==nil~then~error;\\
      &~~~~L.type=L.array.type.elem;\\
      &~~~~L.offset=newtemp();\\
      &~~~~gen(L.offset=E.addr*L.type.width);\\
      \}
      \end{align*}
      $$

      > 确定数组元素**维度**和数组**标识符**后，记录数组**基址**和数组元素**类型**，并生成 用类型**宽度**和表达式值计算**偏移量** 的三地址码

    - $L\rarr L_1[E]\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~L.array=L_1.array;\\
      &~~~~L.type=L_1.type.elem;\\
      &~~~~t=newtemp();\\
      &~~~~gen(t=E.addr*L.type.width);\\
      &~~~~L.offset=newtemp();\\
      &~~~~gen(L.offset=L_1.offset+t);\\
      \}
      \end{align*}
      $$
      
      > 更高维数组元素形成时，传递数组基址，取更深维度的元素类型，并生成 借助**临时变量**计算**更深维度偏移量** 的三地址码



### 6.3 控制流语句的翻译

*主要任务：*

- 结合布尔表达式的翻译，生成具有**控制流结构**的三地址码
- 正确处理**指令标号**的记录和**跳转**三地址码的生成

---

*控制流语句的代码结构：*

- 跳转的逻辑结构很简单，重点是在合适的地方插入`goto`语句

> 详见编译原理随堂笔记仓库

---

*控制流语句的SDT：*

- <u>文法符号与属性</u>

  - `P`：开始符号

  - `S`：控制流代码块

    - `S.code`：综合属性，存放完整的三地址码

    - `S.next`：继承属性，是一个地址，地址中存放了紧跟在`S.code`之后的指令标号，即`S`**后继指令的标号**

      > **指令标号**可以标识一条**三地址指令**

    - `S.first`：继承属性，是一个地址，地址中存放了在`S.code`的**第一条指令的标号**

  - `B`：布尔表达式

    - `B.ture`：继承属性，是一个地址，地址中存放了当`B`为真时控制流转向的指令标号
    - `B.false`：继承属性，是一个地址，地址中存放了当`B`为假时控制流转向的指令标号

  - `E`：表达式

    > 与赋值语句中的一致

  - `L`：数组元素

    > 与赋值语句中的一致

- <u>副作用</u>

  - `newlabel()`：生成一个用于**存放标号**的临时变量，返回其**地址**

  - `label(L)`：将**下一条**三地址指令的**标号**赋值给`L`（指向的地址）

  - `gen(code)`

    > 之前的小节介绍过

- <u>语法规则和语义动作</u>

  - 文法开始/完整控流代码块形成：

    - $P\rarr\{a_1\}S\{a_2\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~S.next=newlabel();\\
      &\}\\
      &a_2:\{\\
      &~~~~label(S.next);\\
      &\}
      \end{align*}
      $$

      > 形成代码块前，先生成存放其后继指令的**地址空间**（**代码块内**可能会用到）；
      >
      > 形成代码块后，将**下一条**三地址指令标号赋值给其**后继指令**

    - $S\rarr\{a_1\}S_1\{a_2\}S_2$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~S_1.next=newlabel();\\
      &\}\\
      &a_2:\{\\
      &~~~~label(S_1.next);\\
      &~~~~S_2.next=S.next\\
      &\}
      \end{align*}
      $$

      > 形成第一个代码块前，先生成存放其**后继指令**的地址空间；
      >
      > 形成第一个代码块后、形成第二个代码块前，将**下一条**三地址指令标号赋值给**第一个**代码块的**后继指令**，并让**第二个**代码块的**后继指令**与代码块**整体**的保持一致 
      >
      > > 这里第二个代码块也是最后一个代码块，所以其后继指令应当与代码块整体的相同

  - **完整赋值语句**的形成：$S\rarr id=E;\{a\}|L=E;\{a\}$

    > 上一小节已经讲过，这里省略

  - 控制流结构的形成

    - $S\rarr if~\{a_1\}B~then~\{a_2\}S_1$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B.true=newlabel();\\
      &~~~~B.false=S.next;\\
      &\}\\
      &a_2:\{\\
      &~~~~label(B.ture);\\
      &~~~~S_1.next=S.next;\\
      &\}
      \end{align*}
      $$

      > 形成布尔表达式前，先生成存放**逻辑为真时跳转到的标号**的地址空间（**布尔表达式**内可能会用到），并让**逻辑为假时跳转到的标号**与代码块**整体**的后继指令标号保持一致；
      >
      > 形成**最后一个代码块**前，将**下一条**三地址指令标号赋值给**逻辑为真时跳转到的标号**，并让**最后一个**代码块的**后继指令**与代码块**整体**的保持一致 

    - $S\rarr if~\{a_1\}B~then~\{a_2\}S_1~\{a_3\}else~\{a_4\}S_2$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B.true=newlabel();\\
      &~~~~B.false=newlabel();\\
      &\}\\
      &a_2:\{\\
      &~~~~label(B.ture);\\
      &~~~~S_1.next=S.next;\\
      &\}\\
      &a_3:\{\\
      &~~~~gen(goto~S.next);\\
      &\}\\
      &a_4:\{\\
      &~~~~label(B.false);\\
      &~~~~S_2.next=S.next;\\
      &\}
      \end{align*}
      $$

      >形成布尔表达式前，先生成存放**逻辑为真和逻辑为假时跳转到的标号**的地址空间；
      >
      >形成**第一个代码块**前，将**下一条**三地址指令标号赋值给**逻辑为真时跳转到的标号**，并让**第一个**代码块的**后继指令**与代码块**整体**的保持一致；
      >
      >形成**第一个代码块**后，生成一条 **跳转**到代码块**整体后继指令** 的跳转三地址指令；
      >
      >形成**最后一个代码块**前，将**下一条**三地址指令标号赋值给**逻辑为假时跳转到的标号**，并让**最后一个**代码块的**后继指令**与代码块**整体**的保持一致 

    - $S\rarr while~\{a_1\}B~do~\{a_2\}S_1\{a_3\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~S.begin=newlabel();\\
      &~~~~label(S.begin);\\
      &~~~~B.true=newlabel();\\
      &~~~~B.false=S.next;\\
      &\}\\
      &a_2:\{\\
      &~~~~label(B.true);\\
      &~~~~S_1.next=S.begin;\\
      &\}\\
      &a_3:\{\\
      &~~~~gen(goto~S.begin);\\
      &\}\\
      \end{align*}
      $$

      > 读到`while`关键字之后，生成存放代码块整体**第一条指令**标号的地址空间，然后直接将其赋值为下一条三地址指令标号；
      >
      > > `while`语句块的**第一条指令**就是布尔表达式的**逻辑判断**
      >
      > 形成布尔表达式前，先生成存放**逻辑为真时跳转到的标号**的地址空间，并让**逻辑为假时跳转到的标号**与代码块**整体**的后继指令标号保持一致；
      >
      > 形成**最后一个代码块**前，将**下一条**三地址指令标号赋值给**逻辑为真时跳转到的标号**，并让**最后一个**代码块的**后继指令**与代码块**整体的第一条指令**保持一致；
      >
      > 形成**第一个代码块**后，生成一条 **跳转**到代码块**整体第一条指令** 的跳转三地址指令；

---

*`switch-case`语句的翻译：*

- `switch-case`的直观翻译方式：
  $$
  switch~E\{a_1\}\\
  case~V_1:\{a_2\}S_1\{a_3\}\\
  case~V_2:\{a_4\}S_2\{a_5\}\\
  ...\\
  case~V_{n-1}:\{a_{2n-2}\}S_{n-1}\{a_{2n-1}\}\\
  default~:\{a_{2n}\}S_n\{a_{2n+1}\}
  $$

  - 新增特殊变量
    - `Vk`：第`k`个分支的**入口值**
    - `Lk`：存放第`k+1`个分支**第一条指令标号**的地址空间
    - `t`：存放分支依据**表达式的值**
    - `next`：存放整体代码块**下一条指令标号**的地址空间

  $$
  \begin{align*}
  &a_1:\{\\
  &~~~~t=newtemp();\\
  &~~~~gen(t=E.addr);\\
  &~~~~next=newlabel();\\
  &\}\\
  &a_{2k-2}:\{\\
  &~~~~label(L_{k-1});\\
  &~~~~L_k=newlabel();\\
  &~~~~gen(if~t~!=V_k~goto~L_k);\\
  &\}\\
  &a_{2k-1}:\{\\
  &~~~~gen(goto~next);\\
  &\}\\
  &a_{2n}:\{\\
  &~~~~label(L_{n-1});\\
  &\}\\
  &a_{2n+1}:\{\\
  &~~~~label(next);\\
  &\}\\
  \end{align*}
  $$

  - `switch-case`语句开始分支测试前，生成将依据**表达式值**保存至临时变量的三地址码，并为存放**整体代码块下一条指令的标号**开辟内存空间

    > 那个`next=newlabel()`放在第一次使用`next`前也可以

  - 每个测试分支中，形成代码块前，先给该**分支对应标号赋值**，再生成**不满足条件跳转**至下一个分支标号的三地址码；形成代码块后，生成跳转至整体代码块下一条指令的三地址码

    > 第一个测试分支不需要给自己的标号赋值，只需要生成不满足条件的跳转三地址码

  - 默认分支中，形成代码块前，给该**分支对应标号赋值**；形成代码块后，给**整体代码块下一条指令对应**的标号赋值

- `switch-case`的**分支测试代码集中**翻译方式：
  $$
  switch~E\{a_1\}\\
  case~V_1:\{a_2\}S_1\{a_3\}\\
  case~V_2:\{a_4\}S_2\{a_5\}\\
  ...\\
  case~V_{n-1}:\{a_{2n-2}\}S_{n-1}\{a_{2n-1}\}\\
  default~:\{a_{2n}\}S_n\{a_{2n+1}\}
  $$

  - 新增特殊变量
    - `test`：分支集中测试块的第一条指令标号地址
  - 新增副作用
    - `map`：记录分支测试**入口值**与分支测试**标号**的映射关系，方便批量生成**分支测试代码**

  $$
  \begin{align*}
  &a_1:\{\\
  &~~~~t=newtemp();\\
  &~~~~gen(t=E.addr);\\
  &~~~~test=newlabel();\\
  &~~~~gen(goto~test);\\
  &~~~~next=newlabel();\\
  &\}\\
  &a_{2k-2}:\{\\
  &~~~~L_k=newlabel();\\
  &~~~~label(L_{k});\\
  &~~~~map(V_k,L_k);\\
  &\}\\
  &a_{2k-1}:\{\\
  &~~~~gen(goto~next);\\
  &\}\\
  &a_{2n}:\{\\
  &~~~~L_n=newlabel();\\
  &~~~~label(L_{n});\\
  &\}\\
  &a_{2n+1}:\{\\
  &~~~~gen(goto~next);\\
  &~~~~label(test);\\
  &~~~~gen(if~t=V_k~goto~L_k);\\
  &\}\\
  \end{align*}
  $$

  - `switch-case`语句开始分支测试前，生成将依据**表达式值**保存至临时变量的三地址码，生成**跳转至集中分支测试**的三地址码，并为存放**整体代码块下一条指令的标号**开辟内存空间

  - 每个测试分支中，形成代码块前，开辟该分支对应的查号，并给**标号赋值**为下一条指令，再将该分支测试**入口值**与**标号**的添加至映射表；形成代码块后，生成跳转至整体代码块下一条指令的三地址码

  - 默认分支中，形成代码块前，开辟该分支对应的查号，并给**标号赋值**为下一条指令；形成代码块后，生成跳转至整体代码块下一条指令的三地址码，再给**集中分支测试的标号**赋值，然后根据**映射表**批量生成分支**入口值对比并跳转至对应标号**的三地址码

    > 可以增加一种`case`指令，`case t V L`等同于`if t==V goto L`，但`case`指令更容易被最终的代码生成器**探测**到，从而对这些指令进行**特殊处理**

  

### 6.4 布尔表达式的翻译

*主要任务：*

- 解析布尔表达式的含义，生成不同逻辑值下的**跳转**三地址码
- 正确处理**逻辑运算**对代码跳转的影响

---

*布尔表达式的SDT：*

- <u>文法符号与属性</u>

  - `B`：布尔表达式

    > 与**控制流语句**中的一致

    - `B.true`
    - `B.false`

  - `E`：表达式

    > 与**赋值语句**中的一致

  - `relop`：关系运算符的正则定义，包括`<, <=, >, >=, ==, !=`

  - `or`

  - `and`

  - `not`

    > 优先级：`not > and > or`
    >
    > 在语法规则中，可以通过人为地限制**使用产生式归约的条件**来实现不同的优先级

  - `true`

  - `false`

- <u>副作用</u>

  > 之前的小节都介绍过

  - `newlabel()`

  - `label(L)`

  - `gen(code)`

- <u>语法规则和语义动作</u>

  - 由**关系运算符**形成布尔表达式

    - $B\rarr E_1~relop~E_2\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~gen(if~E_1.addr~relop~E_2.addr~goto~B.ture);\\
      &~~~~gen(goto~B.false);\\
      &\}\\
      \end{align*}
      $$

      > 生成关系运算符的跳转三地址码

  - 由**逻辑值**形成布尔表达式

    - $B\rarr true\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~gen(goto~B.true);\\
      &\}\\
      \end{align*}
      $$

      > 直接生成跳转到**真出口**的三地址码
      >
      > > 这里所说的“**出口**”指的就是要跳转到的**指令标号**

    - $B\rarr false\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~gen(goto~B.false);\\
      &\}\\
      \end{align*}
      $$

      > 直接生成跳转到**假出口**的三地址码

  - 通过**逻辑运算符**连接布尔表达式

    - $B\rarr(\{a_1\}B_1)$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B_1.true=B.true;\\
      &~~~~B_1.false=B.false;\\
      &\}\\
      \end{align*}
      $$

      > 子表达式形成前，让其**真、假出口**与父表达式保持相等

    - $B\rarr not\{a_1\}B_1$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B_1.true=B.false;\\
      &~~~~B_1.false=B.true;\\
      &\}\\
      \end{align*}
      $$

      > 子表达式形成前，让其**真、假出口**与父表达式保持相反

    - $B\rarr\{a_1\}B_1~or~\{a_2\}B_2$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B_1.false=newlabel();\\
      &~~~~B_1.true=B.true;\\
      &\}\\
      &a_2:\{\\
      &~~~~label(B_1.false);\\
      &~~~~B_2.true=B.true;\\
      &~~~~B_2.false=B.false;\\
      &\}\\
      \end{align*}
      $$

      > 第一个子表达式形成前，先让其**真出口**与父表达式保持相等，再给其**假出口**生成临时变量；
      >
      > 第二个子表达式形成前，先将第一个表达式的**假出口**赋值为**下一条语句标号**，再让第二个子表达式的**真、假出口**与父表达式保持相等

    - $B\rarr\{a_1\}B_1~and~\{a_2\}B_2$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B_1.true=newlabel();\\
      &~~~~B_1.false=B.false;\\
      &\}\\
      &a_2:\{\\
      &~~~~label(B_1.true);\\
      &~~~~B_2.true=B.true;\\
      &~~~~B_2.false=B.false;\\
      &\}\\
      \end{align*}
      $$

      > 第一个子表达式形成前，先让其**假出口**与父表达式保持相等，再给其**真出口**生成临时变量；
      >
      > 第二个子表达式形成前，先将第一个表达式的**真出口**赋值为**下一条语句标号**，再让第二个子表达式的**真、假出口**与父表达式保持相等



### 6.5 过程调用语句的翻译

*主要任务：*

- 解析过程调用的参数，生成**设置实参和调用过程**的三地址码

---

*过程调用语句的代码结构：*

- 语句模式：`id(E1, E2, ..., En)`

- 代码流程

  1. 运算各表达式的三地址码，计算参数值：

     `id(`

     ​	`E1.code, `

     ​	`E2.code, `

     ​	`..., `

     ​	`En.code`

     `)`

  2. 通过`param`指令将各表达式的值作为函数的实参：

     `param E1.addr`

     `param E2.addr`

     `...`

     `param En.addr`

     > 这种是`param`指令集中的形式。也可以让`param Ek.addr`指令紧跟在`Ek.code`后面，就是分散形式。
     >
     > 分散形式下，需要使用一种数据结构（通常是队列`q`）来存放`Ek.addr`，以便集中生成`param`指令

  3. 调用函数：

     `call id.addr n`

     > `n`代表参数个数

---

*过程调用语句的SDT：*

- <u>文法符号与属性</u>

  - `S`：文法开始符号/过程调用代码结构
  - `Elist`：参数列表
  - `E`：参数表达式
    - `E.addr`：表达式**值的存放地址**

- <u>副作用</u>

  - `gen(code)`

    > 之前的小节都介绍过

- <u>语法规则和语义动作</u>

  - 文法开始/形成**过程调用**框架

    - $S\rarr call~id(Elist)\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~n=0;\\
      &~~~~for~q中的每个t~do\\
      &~~~~~~~~gen(param~t);\\
      &~~~~~~~~n=n+1;\\
      &~~~~gen(call~id.addr,n);\\
      &\}\\
      \end{align*}
      $$

      > 过程调用框架形成后，根据**队列`q`**集中生成所有**设置实参**的`param`三地址指令，最后再生成一条**过程调用**的三地址指令

  - 形成**参数列表**

    - $Elist\rarr E\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~将q初始化为只包含E.addr的队列;\\
      &\}\\
      \end{align*}
      $$

      > 参数列表开始形成时初始化队列`q`

    - $Elist\rarr Elist_1,E\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~将E.addr添加到q的队尾;\\
      &\}\\
      \end{align*}
      $$

      > 参数列表中每增加一个参数就添加一个参数地址至队列`q`中



### 6.6 回填

*基本思想：*

- 生成**跳转**三地址码时，暂不指定跳转的**目标标号**，并将这样的指令放入**列表**中，同一个列表中所有跳转指令的**目标相同**，待能确定目标时，再**填充**列表中指令的目标标号
- 待填充跳转指令组成的**列表**会通过文法符号**综合属性**进行传递，不再需要使用`next true false`这类**继承属性**了，更符合**归约**的思想

---

*布尔表达式的回填：*

- <u>有改动或新增的文法符号及其综合属性</u>

  - `B`：布尔表达式
    - `B.truelist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为`B`的真出口**
    - `B.falselist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为`B`的假出口**
  - `M`：辅助记录的符号
    - `M.quad`：会将下一条指令的标号暂存至该综合属性，之后会用到

- <u>新增的特殊变量</u>

  - `nextquad`：即将生成的下一条三地址码的标号

- <u>新增的副作用</u>

  - `makelist(i)`：创建一个只包含跳转指令`i`的列表，返回列表**指针**

    > 这里的`i`是这条跳转指令本身的标号，不是目标标号

  - `merge(p1, p2)`：将`p1`和`p2`指向的两个列表合并，返回合并后列表**指针**

  - `backpatch(p, i)`：将`i`作为**目标标号**填充`p`指向的列表中的所有**跳转指令**

- <u>有改动的语法规则和语义动作</u>

  - 由**关系运算符**形成布尔表达式

    - $B\rarr E_1~relop~E_2\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B.truelist=makelist(nextquad);\\
      &~~~~B.falselist=makelist(nextquad+1);\\
      &~~~~gen(if~E_1.addr~relop~E_2.addr~goto~\_);\\
      &~~~~gen(goto~\_);\\
      &\}\\
      \end{align*}
      $$

      > 先设置待**填充跳转指令列表**，把**即将生成的两条指令**分别加入真假出口对应的两个列表，再生成关系运算符的**待填充跳转三地址码**

  - 由**逻辑值**形成布尔表达式

    - $B\rarr true\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B.truelist=makelist(nextquad);\\
      &~~~~gen(goto~\_);\\
      &\}\\
      \end{align*}
      $$

      > 先设置待**填充跳转指令列表**，把**即将生成的指令**加入真出口对应的列表，再生成**待填充的跳转三地址码**

    - $B\rarr false\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B.falselist=makelist(nextquad);\\
      &~~~~gen(goto~\_);\\
      &\}\\
      \end{align*}
      $$

      > 先设置待**填充跳转指令列表**，把**即将生成的指令**加入假出口对应的列表，再生成**待填充的跳转三地址码**

  - 通过**逻辑运算符**连接布尔表达式

    - $B\rarr(B_1)\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B_1.truelist=B.truelist;\\
      &~~~~B_1.falselist=B.falselist;\\
      &\}\\
      \end{align*}
      $$

      > 子表达式形成后，让其**真、假出口列表**与父表达式保持相等

    - $B\rarr not\{a_1\}B_1$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~B_1.truelist=B.falselist;\\
      &~~~~B_1.falselist=B.truelist;\\
      &\}\\
      \end{align*}
      $$

      > 子表达式形成后，让其**真、假出口列表**与父表达式保持相等

    - $B\rarr B_1~or~M~B_2\{a_1\}$

      $M\rarr\epsilon\{a_2\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~backpatch(B_1.falselist,M.quad);\\
      &~~~~B.truelist=merge(B_1.truelist,B_2.truelist);\\
      &~~~~B.falselist=B_2.falselist;\\
      &\}\\
      &a_2:\{\\
      &~~~~M.quad=nextquad;\\
      &\}\\
      \end{align*}
      $$

      > 子表达式形成并连接后，先用记录下的第二个子表达式的**第一条指令标号**回填第一个子表达式的**假出口列表**，再将两个子表达式的**真出口列表合并**至父表达式的真出口列表，将第二个子表达式的**假出口列表**赋值给父表达式的假出口列表
      >
      > > 父表达式的真假出口列表待**控制流语句**形成后回填

    - $B\rarr B_1~and~M~B_2\{a_1\}$

      $M\rarr\epsilon\{a_2\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~backpatch(B_1.truelist,M.quad);\\
      &~~~~B.falselist=merge(B_1.falselist,B_2.falselist);\\
      &~~~~B.truelist=B_2.truelist;\\
      &\}\\
      &a_2:\{\\
      &~~~~M.quad=nextquad;\\
      &\}\\
      \end{align*}
      $$

      > 子表达式形成并连接后，先用记录下的第二个子表达式的**第一条指令标号**回填第一个子表达式的**真出口列表**，再将两个子表达式的**假出口列表合并**至父表达式的假出口列表，将第二个子表达式的**真出口列表**赋值给父表达式的真出口列表
      >
      > > 父表达式的真假出口列表待**控制流语句**形成后回填

---

*控制流语句的回填：*

- <u>有改动或新增的文法符号及其综合属性</u>

  - `S`：控制流代码块
    - `S.nextlist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为`S`的下一条指令**
  - `M`：辅助记录的符号
    - `M.quad`：会将下一条指令的标号暂存至该综合属性，之后会用到
  - `N`：辅助记录的符号
    - `N.nextlist`：会将包含**下一条跳转指令**的列表指针标号暂存至该综合属性，之后会用到

- <u>新增的特殊变量</u>

  > 与上一小节介绍的相同

  - `nextquad`

- <u>新增的副作用</u>

  > 与上一小节介绍的相同

  - `makelist(i)`
  - `merge(p1, p2)`
  - `backpatch(p, i)`

- <u>有改动的语法规则和语义动作</u>

  - 文法开始/完整控流代码块形成：

    - $P\rarr S\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~backpatch(S.nextlist,nextquad);\\
      &\}\\
      \end{align*}
      $$

      > 形成代码块后，用**下一条**三地址指令标号回填整体代码块的**后继列表**
      >
      > > 这条回填产生式是我自己猜的，我希望是对的

    - $S\rarr S_1~M~S_2\{a_1\}$

      > $M$的作用与上一小节一致，这里都省略

      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~backpatch(S_1.nextlist, M.quad)\\
      &~~~~S.nextlist=S_2.nextlist\\
      &\}\\
      \end{align*}
      $$

      > 两个代码块拼接完成后，先用记录下的第二个代码块的**第一条指令标号**回填第一个代码块的**后继列表**，再将第二个代码块的后继列表赋值给整体代码块的后继列表

  - **完整赋值语句**的形成：$S\rarr id=E;\{a\}|L=E;\{a\}$
    $$
    \begin{align*}
    &a:\{\\
    &~~~~S.nextlist=null;\\
    &\}\\
    \end{align*}
    $$

    > 完整赋值语句形成后，直接让代码块**后继列表为空**即可
    >
    > > 因为赋值语句只是顺序执行，不需要特殊的跳转

  - 控制流结构的形成

    - $S\rarr if~B~then~M~S_1\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~backpatch(B.truelist, M.quad);\\
      &~~~~S.nextlist=merge(B.falselist,S_1.nextlist);\\
      &\}\\
      \end{align*}
      $$

      > 单分支控制流形成后，先用记录下的子代码块**第一条指令标号**回填布尔表达式的**真出口列表**，再将布尔表达式的**假出口列表**合和子代码块的**后继列表**合并至整体代码块的**后继列表**

    - $S\rarr if~B~then~M_1~S_1~N~else~M_2~S_2\{a_1\}$

      $N\rarr\epsilon\{a_3\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~backpatch(B.truelist,M1.quad);\\
      &~~~~backpatch(B.falselist,M2.quad);\\
      &~~~~S.nextlist=merge(merge(S_1.nextlist,N.nextlist),S_2.nextlist);\\
      &\}\\
      &a_3:\{\\
      &~~~~N.nextlist=makelist(nextquad);\\
      &~~~~gen(goto~\_);\\
      &\}\\
      \end{align*}
      $$

      >双分支控制流形成后，先用记录下的第一个子代码块**第一条指令标号**回填布尔表达式的**真出口列表**，用记录下的第二个子代码块**第一条指令标号**回填布尔表达式的**假出口列表**，再将两个子代码块的**后继列表**与在两个子代码块**之间生成的跳转指令**所在列表合并至整体代码块的**后继列表**

    - $S\rarr while~M_1~B~do~M_2~S_1\{a_1\}$
      $$
      \begin{align*}
      &a_1:\{\\
      &~~~~backpatch(S_1.nextlist,M_1.quad);\\
      &~~~~backpatch(B.truelist,M_2.quad);\\
      &~~~~S.nextlist=B.falselist;\\
      &~~~~gen(goto~M_1.quad);\\
      &\}\\
      \end{align*}
      $$

      > 循环控制流形成后，先用记录下的布尔表达式**第一条指令标号**回子代码块的**后继列表**，用记录下的子代码块**第一条指令标号**回填布尔表达式的**真出口列表**，再将布尔表达式的**假出口列表**赋值给代码块整体的**后继列表**，最后生成跳转到布尔表达式第一条指令的三地址码



## 7 运行存储分配

### 7.1 运行存储分配概述

*运行存储分配策略*

- 编译器要为源程序中出现的一些**数据对象**分配**运行时的存储空间**
- 静态存储分配
- 动态存储分配


### 7.2 静态存储分配



### 7.3 栈式存储分配与调用返回



### 7.4 非局部数据的访问



### 7.5 符号表的组织



## 8 代码优化

>   由于本校考试不考查此部分，所以暂时没有知识总结


## 9 代码生成

​	
