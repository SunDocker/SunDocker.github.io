---
title: 编译原理
abbrlink: 7a2b5672
date: 2022-09-20 16:27:49
tags: 
  - 计算机
  - 编译原理
category: 学习资源
cover: /bgs/bg7.jpeg
---

## 1 绪论

### 1.1 什么是编译

- 编译就是将高级语言(**源语言**)翻译成汇编语言或机器语言(**目标语言**)的过程
- 预处理器
- 编译器
- 汇编器
- 链接器/加载器



### 1.2 编译系统的结构

1. 分析
   1. 词法分析
   2. 语法分析
   3. 语义分析
2. 综合
   1. 中间代码生成
   2. 代码优化
   3. 目标代码生成
3. 辅助
   - 符号表管理
   - 出错处理



### 1.3 词法分析概述

从**源程序**中：识别**单词**，确定类型，生成***token***



### 1.4 语法分析概述

从***token*序列**中：识别**短语**，构造**语法分析树**



### 1.5 语义分析概述

根据**语法分析树**

- 收集**标识符**属性信息，形成**符号表**
- **语义检查**
- 子程序和变量的**静态绑定**



### 1.6 中间代码生成及编译

生成与机器无关、易于优化与转化的中间表示形式（常用**三地址码**）



### 1.7 优化与生成目标机器语言

- 通过**等价**程序变换进行**优化**，提高时空效率
- 生成**目标机器语言**



### 1.8 表格管理

 管理各种**符号表**，辅助语法检查、语义检查，完成静态绑定，为编译的各个阶段提供信息



### 1.9 错误管理

进行各种错误的检查、报告、纠正，以及相应的**续编译处理**



### 1.10 编译程序的组织与生成

编译程序设计的**目标**：

- 程序本身：规模小、速度快、诊断能力强、可移植性好，可扩充性好
- 目标程序：规模小、速度快

前端与后端：

- 前端：与源语言有关、与目标机无关

  > 词法分析、语法分析、语义分析与中间代码生成、与机器无关的代码优化

- 后端：与目标机有关的部分

  > 与机器有关的代码优化、目标代码生成

T形图：

- 描述了**源语言**经编译程序到**目标语言**的过程
- **编译程序的实现语言**可以是高级语言、汇编语言、机器语言，但终究只有**用机器语言实现**才能运行该程序
- T形图可以直观描述语言移植、新语言编译等问题



## 2 程序设计语言及其文法

### 2.1 字母表和串

- **字母表**及其乘积、幂、闭包等运算
- **串**及其连接、幂等运算



### 2.2 文法的定义

文法是一个具有**推导**和**归约**功能的**四元组**：

- **终结符集**（$V_T$）
- **非终结符集**（$V_N$）
- **产生式集**（$P$）
- **开始符号**（$S$）



### 2.3  语言的定义

由文法**开始符号**推导出的所有**句子**构成的集合称为**文法生成的语言**。

文法解决了**无穷语言的有穷表示**问题。

语言有并、连接、幂、闭包等运算。



### 2.4 文法的分类

> 从上至下，要求依次累加

- 无限制文法/短语结构文法
  - 产生式**左部**至少包含一个**非终结符**

- 上下文有关文法
  - 产生式**左部长度小于右部**

- 上下文无关文法
  - 产生式**左部仅为非终结符**

  > <u>左部仅有一个非终结符，右部长度大于左部</u>

- 正则文法
  - 仅允许**左线性**或**右线性**



### 2.5 CFG的分析树

- 分析树是**推导**的图形化表示：
  - 根节点：文法**开始符号**
  - 内部结点：**产生式**
    - **左部**：该节点
    - **右部**：子结点从左到右
  - 叶结点：非终结符或终结符
  - **树的产出/边缘**：从左到右排列叶节点
  
- （句型的）短语：分析树中每一棵**子树的边缘**

  > 直接短语（简单短语）：高度为2的子树的边缘

- 二义性文法与消歧规则



## 3 词法分析

### 3.1 正则表达式

- 正则表达式是描述**正则语言**的**更紧凑**的表示方法
- 它可以**递归构建**
- 与**正则文法**等价
- 有自己的**代数定律**



### 3.2 有穷自动机

> 核心就是：`状态 + 输入 + 转换`

- 有穷自动机（FA）：

  - 一种处理系统的数学模型。这种处理系统由**输入带、读头、有穷控制器**构造，可以根据当前**状态**和**输入**转入下一状态。
  - FA有其定义/接收的**语言**
  - FA遵循最长子串匹配

- DFA：一种代表FA模型的**五元组**

  - **有穷状态集**（$S$）

  - **输入字母表**（$\Sigma$）

    > $\epsilon\notin\Sigma$

  - **转换函数**（$\sigma$）：$S\times\Sigma\rarr S$

  - **开始状态**（$s_0$）

  - **接收状态**（$F$）

- NFA：一种代表FA模型的**五元组**

  - **有穷状态集**（$S$）

  - **输入字母表**（$\Sigma$）

  - **转换函数**（$\sigma$）：$S\times\Sigma\rarr 2^S$

    > $\epsilon-NFA$与$NFA$的区别就在于转换函数：$S\times(\Sigma\cup\{\epsilon\})\rarr 2^S$

  - **开始状态**（$s_0$）

  - **接收状态集合**（$F$）




### 3.3 RE与FA的转换

- RE$\rarr$NFA：**分解、递归**
  - RE与NFA的对应规则
- NFA$\rarr$DFA：**状态转换表**
  - 子集构造法



### 3.4 识别单词的DFA

- 识别**标识符的**DFA
- 识别**无符号数**的DFA
- 识别**各进制无符号整数**的DFA
- 识别**注释**的DFA
- 识别**各类单词**的DFA



### 3.5 词法分析阶段的错误处理

- 错误类型
  - **单词拼写**错误
  - **非法字符**
- **错误处理程序**
  - 调用时机：**当前状态与当前输入信息为空**
  - 处理方式：查找已扫描字符串的最后一个**终态字符**
    - 找到了：识别成一个**单词**，回到初态
    - 没找到：错误恢复策略（**恐慌模式**）



## 4 语法分析

### 4.1 自顶向下分析概述

- **<u>自顶向下</u>构造语法分析树**，每次用**最左非终结符**（树的最左非终结符节点、最左推导），根据**输入符**，选择其合适的**产生式**，进行替换（生成子节点）
- 一般的自顶向下分析往往会因为**产生式选择的不确定性**而需要**回溯**，但**<u>预测分析</u>**就不需要回溯，它依据**预测分析表**，是一种**确定的自顶向下分析方法**
- 并不是所有文法都直接适用于自顶向下的分析，文法转换就是要**改造这些文法**以使其适合**自顶向下的分析**。
  - 常见的文法转换就是**消除左递归**，因为左递归会导致**无限递归**。
  - **提取左公因子**也是一种文法转换方式，本质是在**推迟决定**，从而**减少回溯**。
  - 当然，还要消除**文法的二义性**



### 4.2 预测分析法

- 构造与检查文法
  - 构造一般文法
  - 改造文法：消除二义性、消除左递归、消除回溯
  - 检查是否为LL(1)文法
- 设计算法
  - 递归的预测分析：”递归“程序
  - 非递归的预测分析：下推自动机



#### 4.2.1 适合预测分析的文法

> 目标：构造不需要回溯、可用于预测分析的文法（前提是要先适用于自顶向下分析）。
>
> 注：可以将下述文法看成**上下文无关文法**的改进，在此基础上加入或减少约束。

- S_文法

  - 产生式**右部**以**终结符**开始（不包含$\epsilon$产生式）
  - 同一非终结符各个候选式的**首终结符**都不相同

- q_文法

  - 产生式**右部**或为$\epsilon$，或以**终结符**开始

  - 具有相同左部的产生式有**不相交的可选集**

    - <u>***可选集***</u>：可以使用该产生式推导时的**输入符号**集合，称为这个产生式的可选集

      > 如果是条空产生式，则可选集等于其左部非终结符的**后继符号集**。
      >
      > > <u>***非终结符的后继符号集***</u>：可能在某个句型中**<u>紧跟</u>在该非终结符后的终结符**
      >
      > > 具体计算方法在下文中有介绍

- LL(1)文法：<u>同一非终结符各个**产生式**的**可选集**互不相交</u>

  > 下面这三条限制其实就是为了保证“同一非终结符各个产生式的可选集互不相交”

  - 同一非终结符各个**候选式**的**串首终结符集**不相交

    > <u>***串首终结符集***</u>：可以从文法符号(串)推导出的所有符号串的**串首终结符**，称为这个文法符号(串)的串首终结符集
    >
    > > 串首终结符：串首第一个符号，并且是终结符。简称首终结符

  - 同一非终结符各个**候选式**至多有一个能**推导出$\epsilon$**

  - 同一非终结符若存在一个候选式能推导出$\epsilon$，则该非终结符的**后继符号集**和其他候选式的**串首符号集**互不相交

- 非终结符FIRST集的计算

  1. 处理所有**空产生式**和**右部以终结符开头**的产生式：直接把$\epsilon$或右部开头的终结符加入左部非终结符的FIRST集
  2. 处理**右部以非终结符开头**的产生式
     - 始终保持**右部开头**非终结符的FIRST集**包含于**该产生式<u>**左部**非终结符</u>的FIRST集
     - 若**右部开头**非终结符的FIRST集中有$\epsilon$，则要继续保持**紧邻右边符号**的FIRST集**包含于**该产生式<u>**左部**非终结符</u>的FIRST集，以此递归，直到不出现$\epsilon$

  > 上面说的是非终结符的FIRST集，
  >
  > - 如果要求终结符的FIRST集，就是只包含该终结符一个元素的集合
  >
  > - 如果要求文法符号串的FIRST集，从左向右看，出现$\epsilon$就累加即可，如果都能推导出$\epsilon$就再加入$\epsilon$

- 非终结符的FOLLOW集的计算

  1. 将**结束标记**加入<u>开始符号的FOLLOW集</u>中
  2. 不断遍历所有产生式，直到无法再添加新的终结符到某一FOLLOW集中，添加规则为：
     - 单看**产生式右部**，跟在<u>某一非终结符</u>**后面的符号串的FIRST集**加入该非终结符的FOLLOW集中（除了$\epsilon$）
     - 看**整条产生式**，<u>**右部结尾**的非终结符</u>，以及可能因右方非终结符推导出$\epsilon$而**变成右部结尾**的非终结符，其FOLLOW集要**包含**左部非终结符的FOLLOW集

- 产生式的SELECT集的计算

  - 若是空产生式，则为**左部**非终结符的**FOLLOW集**
  - 若非空产生式，则为**右部**符号串的**FIRST集**




#### 4.2.2 预测分析算法

> 使用以下算法的必要条件是，文法适用于预测分析

- 递归的预测分析法

  - 从文法**开始符号的产生式**开始，遍历右部符号（即**调用文法开始符号的过程**）

    > 遍历符号的过程中，每次取得一个输入，并根据**SELECT集**选择产生式

    - 若为终结符，则必须等于当前输入符号，否则报错
    - 若为非终结符，则“递归”调用**该非终结符对应的过程**

  - 最后一个输入符号必须是终结符

- 非递归的预测分析法（借助**下推自动机**，初始时，栈顶为开始符，栈底为结束符）

  - 对比输入符号与栈顶符号，直到栈顶和输入都为结束符
  - 若栈顶符号为**终结符**
    - 二者**相等**，则弹栈，消耗输入符号，读头后移
    - 二者不相等，则报错
  - 若栈顶符号为**非终结符**：根据SELECT集选择**产生式**，根据产生式弹栈并入栈，不消耗输入符号

  > 非递归的，也叫表驱动的预测分析法，预测分析表的定义如下：
  >
  > - 行为非终结符，列为输入符号
  > - 表项为产生式，其左部行代表的非终结符，且列代表的输入符号属于其SELECT集



#### 4.2.3 预测分析法的错误处理

- 错误检测
  - 最左/栈顶**终结符**与当前输入符号不匹配
  - 最左/栈顶**非终结符**与当前输入符号在**预测分析表**中无可用产生式
- 错误恢复：恐慌模式
  - 最左/栈顶**终结符**与当前输入不匹配时：直接忽略输入符号
  - 最左/栈顶**非终结符**与当前输入符号在**预测分析表**中无可用产生式：
    - 若输入符号在该非终结符的FOLLOW集中（同步词法单元），则忽略/弹出该非终结符
    - 若输入符号不在该非终结符的FOLLOW集中，则忽略输入符号



### 4.3 自底向上分析概述

- 自底向上分析也叫**移入-归约分析**

  > 借助**栈**来理解

  - 移入：将**输入符号**压入栈

  - 归约：从栈中依次**弹出**能构成**产生式右部**的若干个符号，然后将**左部压入栈**（最左归约）

    > 最左归约称为规范归约、最右推导称为规范推导

  - 移入-归约分析中的关键问题是**正确识别最左直接短语（句柄）**

    > **<u>句柄：当前句型的最左直接短语</u>**

- **LR分析**是移入-归约分析的重要方法

  > 从**左**到右扫描，反向构造最**右**推导

  - 用**状态**表示**句柄识别的进展程度**，<u>状态栈与符号栈平行</u>（栈中**元素个数保持相等**）

    > 状态的可视化表示就是在产生式右部插入一个圆点，代表**离可以使用该产生式归约**还差什么符号，**圆点右边的符号**就是需要的符号
  
    - 移进状态：圆点后面是终结符
    - 待约状态：圆点后面是非终结符
    - 归约状态：圆点后面没有符号

  - 只要构造出正确的**<u>分析表</u>**就可以直观且快速地识别了，分析表的概述如下：
  
    - **一行**对应一个**状态**，一个状态的**一条边**对应于该行的**一个表项**
    - **一列**对应一个**文法符号**，终结符和结束符在**ACTION列组**，非终结符在**GOTO列组**
    - 表项中，$s_n$代表将**所在列对应符号和状态n**同时压入栈符号栈和状态栈；$r_n$代表使用第n个产生式归约，同时弹出**产生式右部**符号(串)和与其**平行的状态**，并压入左部非终结符，再根据**当前栈顶状态**和**该非终结符**找到GOTO列组的项k，这代表着再**将状态k压入栈**；acc代表成功识别，err代表出错
    - 从状态栈只有初始状态0、符号栈只有结束符$\$$开始，根据**当前状态(行)和输入符号(列)**找到表项，执行对应的操作，直到读取输入后找到的表项为acc或err
  
  
  > 所以，**构造出文法的分析表**是LR分析的关键



### 4.4 LR(0)分析

> :star:LR系列的相关概念较多，暂不探讨定义这些概念的内在原因，只要能将其**<u>应用到问题中</u>**即可

- LR(0)相关<u>概念</u>

  - **增广文法**：新增<u>开始符号</u>，它能推导出原开始符号（$S'\rarr S$）

    > 增广文法让分析器**只有一个接受状态**

  - **项目**：项目描述了**句柄识别的状态**

    - 移进项目

      > 开始符号对应的移进项目称为<u>初始项目</u>（$S'\rarr\cdot S$）

    - 待约项目

    - 归约项目

      > 开始符号对应的归约项目称为<u>接收项目</u>（$S'\rarr S\cdot$）

  - **后继项目**：同属一个产生式但圆点只差一个符号，圆点在后的是后继项目

  - **等价的项目/项目集闭包**：对于一个**待约**项目，它的等价项目就是，以该待约项目**圆点后面的符号为<u>左部</u>**的所有<u>产生式</u>将**圆点放在<u>右部</u>第一个符号前**得到的项目；被等价推出的**待约**项目可以继续等价推出，直到不能再推出新的待约项目。这样推出的所有项目都放在一个集合中，这个集合就是**项目集闭包**。

    > 对于移进项目和归约项目，它们可以被待约项目等价推出，但不能等价推出别的项目。如果它们不能由某个待约项目等价推出，则它们没有等价项目

  - 项目集对应于**文法符号X(包括终结符和非终结符)**的**后继项目集闭包**（`GOTO(I, X)`函数）：项目集中**圆点<u>右紧邻符号为X</u>**的每一个项目的**<u>后继项目</u>的项目集闭包的并**

- LR(0)<u>自动机与分析表</u>

  - 自动机的构造

    1. 初始项目（$S'\rarr\cdot S$）的**项目集闭包**构成**状态0**
    2. 对于**每一个现有状态**，求其对于**每一个文法符号(包括终结符和非终结符)**的后继项目集闭包（`GOTO(I, X)`），若`GOTO(I, X)`不为空，则将其作为一个新的状态（如果是已经存在的状态就不必当成新状态了），并生成一条当前状态指向`GOTO(T, X)`对应状态的**有向边**，边上的符号为当前文法符号
    3. 循环执行2**直到不再增加有向边**

  - 分析表的构造

    - **接收项目**是单独在一个状态里，对应**接收状态**，在表中与结束符$\$$形成表项$acc$

    - 对于一个状态i（一行）

      > 一个状态中若既有**归约项目**又有其他类型的项目，则会出现冲突，这里先不考虑

      - 出边上是**非终结符**的，对应该行的**GOTO表项**，为有向边指向的状态编号$j$
      - 出边上是**终结符**的，对应该行的**ACTION表项**，为有向边指向的状态$s_j$
      - 若**没有出边**，或者说状态中**只有一个归约项目**，则该行的ACTION表项全为$r_k$（k为该归约项目对应的**产生式编号**）

- LR(0)会有**移进/归约**冲突和**归约/归约**冲突

  - 对应到自动机中，就是一个状态中**同时存在归约项目和其他类型项目**，或者同时存在**多个归约项目**，导致遇到下一个输入时无法判断执行什么动作
  - 对应到分析表中，就是ACTION列组的**一个表项**会有**两个可选值**
  - 出现问题的本质原因是，LR(0)分析没有**向前查看符号**，没考虑**上下文环境**



### 4.5 SLR分析

- SLR分析基本思想

  > S：Simple，仅通过FOLLOW集化解冲突

  - 是对LR(0)分析的改进，**在LR(0)分析的基础上**，不是遇到所有输入符号都能归约的，因为归约后左部符号的**FOLLOW集**中可能没有该输入符，也就是归约后的符号后面不可能紧接这个输入符

  - 当遇到LR(0)中所述冲突时，要考察两种集合(是两种，不是两个。第一种里只有一个，第二种里可以有多个)：

    - 第一种是状态中**所有移进/待约项目**<u>圆点右侧符号构成的集合</u>，
    - 第二种是状态中所有**归约项目**对应<u>产生式左部非终结符的**所有FOLLOW集**</u>。

  - 当这些集合两两不相交时：

    > 若不能做到两两不相交，则说明SLR无法解决这种冲突

    - 若**输入符号**在<u>圆点右侧符号构成的集合</u>中，则执行对应的移进ACTION；
    - 若**输入符号**在<u>某个归约项目左部的FOLLOW集</u>中，则执行对应的归约ACTION。
    - 其他情况报错

- SLR<u>自动机与分析表</u>

  - 自动机的构造：与LR(0)一样的

  - 分析表的构造：在LR(0)构造的分析表基础上，只有**ACTION列的终结符**在对应状态中归约项目左部符号的**FOLLOW集**中时，才进行归约，否则的话，要么是**移进**，要么**表项为空**

    > 若这样做之后一个表项中还是会留下多个动作，则说明SLR无法解决这种冲突

- SLR分析中的冲突

  - 上述的两种集合不能做到**两两不相交**
  - 本质原因是，对于归约项目，输入符号在其左部**FOLLOW集**中，只是能归约一个**必要条件**，并非充分条件



### 4.6 LR(1)分析

- 基本思想与概念

  - 在LR分析的**特定位置**，对于非终结符A，并非FOLLOW(A)中的所有符号都可以接在A后面，所以并不是输入符在FOLLOW(A)中了就可以使用以A为左部的这条产生式进行归约，我们需要找到**非终结符A在特定位置的后继符**

  - 规范LR(1)项目：$A\rarr\alpha\cdot\beta, a$（$第一分量,第二分量$）

    - 第一分量：右部带圆点的产生式（就是之前对于项目的定义）

    - 第二分量：展望符，代表当前状态下A后面可以紧跟的终结符。对于归约项目（$A\rarr\alpha\cdot,a$），代表输入符号为a时才能使用该产生式归约

      > 对于移入项目和待约项目（$A\rarr\alpha\cdot\beta, a且\beta\ne\epsilon$），**展望符与之无关**，但为了定义的完整，把它写出来了

  - <u>**等价**LR(1)项目/**展望符**的计算</u>：

    - 第一分量：就是之前定义过的**等价项目**

    - 第二分量/展望符：要看等价项目产生式的**左部**在原项目中**右边的符号(串)**$\beta$。若$\beta$能推出空（或者$\beta$本身就是空的），则直接继承相同的展望符；否则，对于$FIRST(\beta)$中的<u>每个终结符</u>，都可以作为**展望符**与相同的**第一分量**构成一个等价的项目

      > 从计算展望符的角度讲，就要从初始项目$S'\rarr\cdot S,\$$出发按照自动机的构造方法去计算了

- LR(1)的自动机和分析表

  > 相比于LR(0)，LR(1)对于CLOSURE、GOTO、项集族、自动机、分析表构造算法都做了适合于**展望符与归约项目**的修改

  - 自动机的构造：从初始项目$S'\rarr\cdot S,\$$开始，与LR(0)的生成规则类似，只是在计算项目等价的时候要考虑**展望符**

  - 分析表的构造：

    - 对于不涉及归约项目的状态，处理方法与LR(0)相同

    - 对于涉及归约项目的状态，只有ACTION列(输入符号)是状态中归约项目的**展望符**时才能规约

      > 之前构造SLR的时候，是遇到左部FOLLOW集中的符号都能规约

### 4.7 LALR分析

- LALR基本思想与概念

  - LR(1)的状态过多，其中有些状态是可以合并的
  - **同心项目集**（同心状态）：只保留第一分量时(重复的只留一个)，完全相同的项目集
  - 同心项目集是可以合并成一个状态的，其实是在对**展望符**进行合并

- LALR的自动机与状态表

  - 自动机：在构造出的LR(1)自动机基础上，合并同心项目并修改边
  - 分析表：与LR(1)的构造方法相同

- LALR的问题

  - 归约-归约冲突：同一个输入符，不知道该用状态中的哪个产生式归约了，因为它们的**展望符**都相同

  - 推迟错误发现：合并同心项集后，虽然不产生冲突，但可能会**推迟错误的发现**

    > LALR分析法可能会作多余的**归约动作**，但绝不会作错误的**移进操作**。因为LALR其实是在合并展望符集合，而展望符与归约有关，与移进无关

- LALR的特点

  - 形式上与LR(1)相同，都有**展望符**
  - 大小上与LR(0)/SLR相当，因为**合并了状态**
  - 分析能力上，$SLR<LALR<LR$。相比于SLR，LALR细化了状态；相比于LR(1)，LALR会延迟错误的发现。








## 5 语法制导翻译

## 6 中间代码生成

## 7 运行存储分配

## 8 代码优化

## 9 代码生成

